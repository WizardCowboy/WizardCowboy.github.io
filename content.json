{"meta":{"title":"Wizard Cowboy's blog","subtitle":null,"description":null,"author":"Wizard Cowboy","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-11T12:07:35.000Z","updated":"2018-05-11T12:07:35.959Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-11T12:22:22.000Z","updated":"2018-05-11T12:22:22.957Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-11T12:02:14.000Z","updated":"2018-05-11T12:02:14.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[BZOJ-3572]世界树","slug":"BZOJ-3572-世界树","date":"2018-05-15T00:14:43.000Z","updated":"2018-05-15T00:32:47.132Z","comments":true,"path":"2018/05/15/BZOJ-3572-世界树/","link":"","permalink":"http://yoursite.com/2018/05/15/BZOJ-3572-世界树/","excerpt":"Description 给你一棵n个点的树，m次询问。 每次询问给出一些关键点，树上所有的点被距离它最近的关键点管辖，求每个关键点管辖多少点。 n ≤ 300000, m ≤ 300000, Sigma(关键点个数) &lt;= 300000","text":"Description 给你一棵n个点的树，m次询问。 每次询问给出一些关键点，树上所有的点被距离它最近的关键点管辖，求每个关键点管辖多少点。 n ≤ 300000, m ≤ 300000, Sigma(关键点个数) &lt;= 300000 Solution 这是一道[HNOI2014]的题。 我们可以用上下DP求出每个点被哪些点管辖，时间复杂度是 O(nm)的。 我们考虑建出虚树，建完虚树后用上下DP处理出虚树上每个点被哪些关键点管辖。 然后我们考虑一个关键点可以管辖哪些点。 对于深度比它大的点，一定是它的子树去掉某些子树。对于深度比它小的点，一定是它的某个祖先的子树去掉它。 我们考虑枚举虚树上的每一条边：如果它两端点不被同一个关键点管辖，则倍增找出一个分界点，然后处理答案即可。 Notice 此题细节较多，处理很麻烦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//// BZOJ-3572.cpp// 高级数据结构/虚树//// Created by 沈擎舟 on 2018/5/15.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 300000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n, m, edgenum = 0, num, idx;int head[N + 5], Belong[N + 5], Size[N + 5], Rest[N + 5], Ans[N + 5], Dis[N + 5], Deep[N + 5], Fa[N + 5][20], X[N + 5], Y[N + 5], Z[N + 5], dfn[N + 5], stack[N + 5];struct node&#123; int vet, next;&#125;edge[2 * N + 5];void addedge(int u, int v)&#123; edge[edgenum].vet = v; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y];&#125;void dfs(int u, int fa)&#123; Size[u] = 1, Deep[u] = Deep[fa] + 1, dfn[u] = ++idx, Fa[u][0] = fa; rep(i, 1, 19) Fa[u][i] = Fa[Fa[u][i - 1]][i - 1]; travel(i, u) &#123; int v = edge[i].vet; if (v == fa) continue; dfs(v, u); Size[u] += Size[v]; &#125;&#125;int lca(int x, int y)&#123; if (Deep[x] &lt; Deep[y]) swap(x, y); per(i, 19, 0) if (Deep[Fa[x][i]] &gt;= Deep[y]) x = Fa[x][i]; if (x == y) return x; per(i, 19, 0) if (Fa[x][i] != Fa[y][i]) x = Fa[x][i], y = Fa[y][i]; return Fa[x][0];&#125;void Build()&#123; sort(X + 1, X + m + 1, cmp); int top = 0; stack[++top] = 1; rep(i, 1, m) &#123; if (X[i] == 1) continue; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; addedge(Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1], stack[top]); top--; &#125; if (!top || stack[top] != u) stack[++top] = u; stack[++top] = X[i]; &#125; while (--top) addedge(stack[top], stack[top + 1]);&#125;void up_dfs(int u)&#123; Z[++num] = u; Rest[u] = Size[u]; travel(i, u) &#123; int v = edge[i].vet; up_dfs(v); if (!Belong[v]) continue; int dis1 = Deep[Belong[v]] - Deep[u], dis2 = Belong[u] ? Deep[Belong[u]] - Deep[u] : INF; if (dis1 &lt; dis2 || dis1 == dis2 &amp;&amp; Belong[v] &lt; Belong[u]) Belong[u] = Belong[v]; &#125; Dis[u] = Deep[Belong[u]] - Deep[u];&#125;void down_dfs(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; int dis1 = Dis[u] + Deep[v] - Deep[u], dis2 = Dis[v]; if (dis1 &lt; dis2 || dis1 == dis2 &amp;&amp; Belong[u] &lt; Belong[v]) Belong[v] = Belong[u], Dis[v] = dis1; down_dfs(v); &#125;&#125;void Solve(int u, int v)&#123; int mid = v; if (Belong[u] == Belong[v]) &#123; Rest[u] -= Size[v]; return; &#125; per(i, 19, 0) &#123; int x = Fa[mid][i]; if (Deep[x] &lt;= Deep[u]) continue; int dis1 = Dis[u] + Deep[x] - Deep[u], dis2 = Dis[v] + Deep[v] - Deep[x]; if (dis1 &gt; dis2 || dis1 == dis2 &amp;&amp; Belong[u] &gt; Belong[v]) mid = x; &#125; Rest[u] -= Size[mid]; Ans[Belong[v]] += Size[mid] - Size[v];&#125;int sqz()&#123; n = read(); rep(i, 1, n) head[i] = -1; Rep(i, 1, n) &#123; int u = read(), v = read(); addedge(u, v), addedge(v, u); &#125; dfs(1, 0); edgenum = 0; rep(i, 1, n) head[i] = -1; int q = read(); while (q--) &#123; m = read(); num = idx = 0; rep(i, 1, m) X[i] = Y[i] = read(), Belong[X[i]] = X[i]; Build(); up_dfs(1); down_dfs(1); rep(i, 1, num) travel(j, Z[i]) Solve(Z[i], edge[j].vet); rep(i, 1, num) Ans[Belong[Z[i]]] += Rest[Z[i]]; rep(i, 1, m) printf(\"%d%c\", Ans[Y[i]], i == m ? '\\n' : ' '); rep(i, 1, num) head[Z[i]] = -1, Belong[Z[i]] = Ans[Z[i]] = Rest[Z[i]] = 0; &#125;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"},{"name":"上下DP","slug":"上下DP","permalink":"http://yoursite.com/tags/上下DP/"}]},{"title":"[BZOJ-2286]消耗战","slug":"BZOJ-2286-消耗战","date":"2018-05-12T01:08:49.000Z","updated":"2018-05-12T01:53:25.114Z","comments":true,"path":"2018/05/12/BZOJ-2286-消耗战/","link":"","permalink":"http://yoursite.com/2018/05/12/BZOJ-2286-消耗战/","excerpt":"Description 给你一棵n个点的树，每条边上有边权。 有m次询问，每次询问都给出一些关键点。你要割掉一些边，使得从1出发无法到达这些关键点。 求割掉边的边权总和最小值。 n ≤ 250000, m ≥ 1, Sigma(关键点个数) ≤ 500000","text":"Description 给你一棵n个点的树，每条边上有边权。 有m次询问，每次询问都给出一些关键点。你要割掉一些边，使得从1出发无法到达这些关键点。 求割掉边的边权总和最小值。 n ≤ 250000, m ≥ 1, Sigma(关键点个数) ≤ 500000 Solution 这是一道[SDOI2011]的题。 首先我们考虑树形DP，F[u]表示从u出发到不了u的子树中所有关键点的最小代价。 那么如果u的儿子v是关键点，那么F[u] += Dis(u, v)——(u, v)这条边一定得割 否则F[u] += min(F[v], Dis(u, v)) 这样我们得到了一个O(n)的DP，但询问m次后时间复杂度就很大了。 所以我们需要用虚树处理，这样总时间复杂度就是O(关键点个数)了。 Notice 因为这道题是树形DP，只要从下向上转移即可，所以不用把虚树边练出来，只要记录每个关键点及LCA在虚树中的父亲即可。 还要倍增预处理祖先和到祖先边权的最小值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//// BZOJ-2286.cpp// 高级数据结构/虚树//// Created by 沈擎舟 on 2018/5/11.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 250000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n, num, tmp, edgenum = 0, Time = 0, top;int head[N + 5], X[N + 5], Y[N + 5], dfn[N + 5], Deep[N + 5], fa[N + 5], Fa[N + 5][20], Dis[N + 5][20], stack[N + 5], flag[N + 5];ll Ans[N + 5];struct node&#123; int vet, val, next;&#125;edge[2 * N + 5];void addedge(int u, int v, int w)&#123; edge[edgenum].vet = v; edge[edgenum].val = w; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;void dfs(int u, int fa)&#123; dfn[u] = ++Time; Deep[u] = Deep[fa] + 1; travel(i, u) &#123; int v = edge[i].vet; if (v == fa) continue; Fa[v][0] = u, Dis[v][0] = edge[i].val; dfs(v, u); &#125;&#125;void Prepare()&#123; rep(i, 1, 18) rep(j, 1, n) &#123; Fa[j][i] = Fa[Fa[j][i - 1]][i - 1]; Dis[j][i] = min(Dis[j][i - 1], Dis[Fa[j][i - 1]][i - 1]); &#125;&#125;int lca(int u, int v)&#123; if (Deep[u] &lt; Deep[v]) swap(u, v); per(i, 18, 0) if (Deep[Fa[u][i]] &gt;= Deep[v]) u = Fa[u][i]; if (u == v) return u; per(i, 18, 0) if (Fa[u][i] != Fa[v][i]) u = Fa[u][i], v = Fa[v][i]; return Fa[u][0];&#125;int dis(int u, int v)&#123; int ans = INF; if (Deep[u] &lt; Deep[v]) swap(u, v); per(i, 18, 0) if (Deep[Fa[u][i]] &gt;= Deep[v]) ans = min(ans, Dis[u][i]), u = Fa[u][i]; return ans;&#125;int cmp(int x, int y)&#123; return dfn[x] &lt; dfn[y];&#125;void Build()&#123; sort(X + 1, X + num + 1, cmp); stack[top = 1] = X[1]; rep(i, 2, num) &#123; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; fa[stack[top]] = Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1]; top--; &#125; if (!top || u != stack[top]) &#123; X[++tmp] = u; stack[++top] = u; &#125; stack[++top] = X[i]; &#125; while (--top) fa[stack[top + 1]] = stack[top];&#125;ll solve()&#123; sort(X + 1, X + tmp + 1, cmp); rep(i, 1, tmp) Ans[X[i]] = 0; per(i, tmp, 2) &#123; if (flag[X[i]]) Ans[fa[X[i]]] += (ll)dis(X[i], fa[X[i]]); else Ans[fa[X[i]]] += min((ll)dis(X[i], fa[X[i]]), Ans[X[i]]); &#125; return Ans[1];&#125;int sqz()&#123; n = read(); rep(i, 1, n) head[i] = -1; Rep(i, 1, n) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w), addedge(v, u, w); &#125; dfs(1, 0); Prepare(); int m = read(); while (m--) &#123; tmp = num = read() + 1, X[1] = 1; rep(i, 2, num) X[i] = Y[i] = read(), flag[X[i]] = 1; Build(); printf(\"%lld\\n\", solve()); rep(i, 2, num) flag[Y[i]] = 0; &#125;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"},{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"}]},{"title":"高级数据结构-虚树","slug":"高级数据结构-虚树","date":"2018-05-11T16:00:00.000Z","updated":"2018-05-12T00:55:56.241Z","comments":true,"path":"2018/05/12/高级数据结构-虚树/","link":"","permalink":"http://yoursite.com/2018/05/12/高级数据结构-虚树/","excerpt":"问题类型 有些问题一次询问需要O(n)的复杂度，但多次询问时间复杂度会很大。 但如果我们只需要用到题目中给出的一些关键点和它们的LCA，并且给出的关键点个数总和并不多，我们可以求出它们的LCA，建成虚树，一次询问就变成了O(关键点个数)","text":"问题类型 有些问题一次询问需要O(n)的复杂度，但多次询问时间复杂度会很大。 但如果我们只需要用到题目中给出的一些关键点和它们的LCA，并且给出的关键点个数总和并不多，我们可以求出它们的LCA，建成虚树，一次询问就变成了O(关键点个数) 解决方案 从上文得知，我们需要找出关键点的LCA并且建成虚树。 这时我们就需要用到栈。（在后文我们简称关键点的LCA为重要点） 我们用栈维护从根到当前关键点的路径上的重要点。 我们先把关键点按DFS序从小到大排序。 然后每次新枚举一个关键点u，求出它与栈顶v（上一个关键点）的LCA:w。 如果u是v的子孙，那么w=v，直接把u加入栈即可。 如果u不是v的子孙，那么w的深度一定比v要浅，所以我们就一直弹栈顶，知道栈顶的深度≤w的深度。 这时如果栈顶不是w，再把w加入栈。最后再把当前关键点加入栈。 我们在每次弹栈的时候，就把栈顶和相邻元素连边。（注意最后还要把栈弹空） 代码演示1234567891011121314151617void Build()&#123; sort(X + 1, X + num + 1, cmp); stack[top = 1] = X[1]; rep(i, 2, num) &#123; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; addedge(stack[top], Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1]); top--; &#125; if (!top || u != stack[top]) stack[++top] = u; stack[++top] = X[i]; &#125; while (--top) addedge(stack[top + 1]], stack[top]);&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-05-11T11:21:10.000Z","updated":"2018-05-12T00:56:36.799Z","comments":true,"path":"2018/05/11/Hello-World/","link":"","permalink":"http://yoursite.com/2018/05/11/Hello-World/","excerpt":"Wizard Cowboy终于有自己的博客啦 搞了半天终于基本成型了。。。","text":"Wizard Cowboy终于有自己的博客啦 搞了半天终于基本成型了。。。","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]}]}