{"meta":{"title":"Wizard Cowboy's blog","subtitle":null,"description":null,"author":"Wizard Cowboy","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-11T12:07:35.000Z","updated":"2018-05-11T12:07:35.959Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-11T12:22:22.000Z","updated":"2018-05-11T12:22:22.957Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-11T12:02:14.000Z","updated":"2018-05-11T12:02:14.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[BZOJ-3160]万径人踪灭","slug":"BZOJ-3160-万径人踪灭","date":"2019-01-09T00:48:44.000Z","updated":"2019-01-09T01:28:37.055Z","comments":true,"path":"2019/01/09/BZOJ-3160-万径人踪灭/","link":"","permalink":"http://yoursite.com/2019/01/09/BZOJ-3160-万径人踪灭/","excerpt":"Description 给你一个只含a，b的字符串，让你选取子序列使得： 位置和字符都关于每条对称轴对称。 不能是连续的一段。求这样的子序列的个数。","text":"Description 给你一个只含a，b的字符串，让你选取子序列使得： 位置和字符都关于每条对称轴对称。 不能是连续的一段。求这样的子序列的个数。 Solution 我们发现不连续的并不好求，那么我们可以通过满足第一个条件的个数减去所有的回文串来得到答案。 求回文串的个数可以用Manacher来做。 那么如何算出所有满足第一个条件的子序列个数呢？ 我们假设F[i]表示以i这里为对称轴，2边字符相等，位置相对的对数。 那么满足第一个条件的子序列个数ans = sigma(2 ^ F[i] - 1) 问题就转化为如何求F[i] 我们发现这样能对F[i]作出贡献的对(x,y)都有共同点：x + y = 2 i 我们可以在每位a上存1，每位b上存0，这样子只有2个a才能产生贡献， 那么一对a对F[i]的贡献就是这个数组的平方后2 i位上的系数。 同理也可以求出一对b对F[i]的贡献。 总时间复杂度为O(n ^ 2) Notice 注意每一对会对F数组产生2次贡献，所以最后计算F的时候要除以2。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = INF + 7;const int N = 263000;const double eps = 1e-6, pi = acos(-1.0);ll read()&#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;&#125;void write(ll y)&#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0');&#125;char st[N + 5], S[N + 5];int Ans[N + 5], X[N + 5], Y[N + 5], Rev[N + 5];int t;void Manacher(char *S, int len, int *Rad)&#123; for (int i = 0, j = 0, k; i &lt; len; i += k) &#123; while (S[i - j - 1] == S[i + j + 1]) j++; Rad[i] = j; for (k = 1; k &lt;= j &amp;&amp; j - k != Rad[i - k]; k++) Rad[i + k] = min(j - k, Rad[i - k]); j = max(j - k, 0); &#125;&#125;ll pow(ll a, ll b, ll Mo)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % Mo; a = a * a % Mo; b &gt;&gt;= 1; &#125; return ans;&#125;struct Complex&#123; double real, imagine; Complex (double real = 0, double imagine = 0) : real(real), imagine(imagine) &#123;&#125;; Complex operator +(const Complex X) &#123; return Complex(real + X.real, imagine + X.imagine); &#125; Complex operator -(const Complex X) &#123; return Complex(real - X.real, imagine - X.imagine); &#125; Complex operator *(const Complex X) &#123; return Complex(real * X.real - imagine * X.imagine, real * X.imagine + imagine * X.real); &#125;&#125;XX[N + 5], YY[N + 5];void FFT(Complex *T, int n, int op)&#123; Rep(i, 0, n) if (i &lt; Rev[i]) swap(T[i], T[Rev[i]]); for (int Size = 1; Size &lt; n; Size &lt;&lt;= 1) &#123; Complex wn = Complex(cos(pi / Size), sin(pi / Size) * op); for (int L = 0; L &lt; n; L += (Size &lt;&lt; 1)) &#123; Complex w = Complex(1, 0); Rep(R, L, L + Size) &#123; Complex x = T[R], y = w * T[R + Size]; T[R] = x + y, T[R + Size] = x - y; w = w * wn; &#125; &#125; &#125;&#125;void Mul(int *T, int n)&#123; int x = 2 * n; int l = 0; for (t = 1; t &lt;= x; t &lt;&lt;= 1) l++; Rep(i, 0, t) Rev[i] = (Rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; l - 1); Rep(i, 0, n) XX[i] = YY[i] = Complex(T[i], 0); Rep(i, n, t) XX[i] = YY[i] = Complex(0, 0); FFT(XX, t, 1); FFT(YY, t, 1); Rep(i, 0, t) XX[i] = XX[i] * YY[i]; FFT(XX, t, -1); rep(i, 0, x) T[i] = (int)(XX[i].real / t + 0.5);&#125;int sqz()&#123; scanf(\"%s\", st); int len = strlen(st); st[len] = ')'; S[0] = '('; rep(i, 0, len) S[2 * i + 1] = '#', S[2 * (i + 1)] = st[i]; len = len * 2 + 3; Manacher(S, len, Ans); int ans1 = 0, ans2 = 0; Rep(i, 0, len) (ans1 += (Ans[i] + 1) / 2) %= Mo; len = strlen(st) - 1; Rep(i, 0, len) if (st[i] == 'a') X[i] = 1; else Y[i] = 1; Mul(X, len); Mul(Y, len); rep(i, 0, 2 * len) (ans2 += pow(2, (X[i] + 1) / 2 + (Y[i] + 1) / 2, Mo) - 1) %= Mo; printf(\"%d\\n\", (ans2 - ans1 + Mo) % Mo);&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/categories/字符串/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://yoursite.com/tags/FFT/"},{"name":"Manacher","slug":"Manacher","permalink":"http://yoursite.com/tags/Manacher/"}]},{"title":"[BZOJ-3527]力","slug":"BZOJ-3527-力","date":"2019-01-08T14:45:35.000Z","updated":"2019-01-09T01:28:24.011Z","comments":true,"path":"2019/01/08/BZOJ-3527-力/","link":"","permalink":"http://yoursite.com/2019/01/08/BZOJ-3527-力/","excerpt":"Description 给出n个数q[i]，给出F[j]的定义如下： F[j] = sigma(q[i] q[j] / (i - j) ^ 2) (i &lt; j) - sigma(q[i] q[j] / (i - j) ^ 2) (i &gt; j) 令E[i] = F[i] / q[i]，求E[i]。","text":"Description 给出n个数q[i]，给出F[j]的定义如下： F[j] = sigma(q[i] q[j] / (i - j) ^ 2) (i &lt; j) - sigma(q[i] q[j] / (i - j) ^ 2) (i &gt; j) 令E[i] = F[i] / q[i]，求E[i]。 Solution 这是一道[ZJOI2014]的题。 E[j] = F[j] / q[j] = sigma(q[i] / (i - j) ^ 2) (i &lt; j) - sigma(q[i] / (i - j) ^ 2) (i &gt; j) 我们令T[x] = x &gt; 0 ? 1 / x ^ 2 : -1 / x ^ 2 那么E[j] = sigma(q[i] * T[j - i]) 转化为卷积的形式后，只要FFT就可以得出结果了。 Notice 要注意T的下标有负数，要同时加上一个数使得下标都变为正数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = INF + 7;const int N = 530000;const double eps = 1e-6, pi = acos(-1.0);ll read()&#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;&#125;void write(ll y)&#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0');&#125;int Rev[N + 5];struct Complex&#123; double real, imagine; Complex (double real = 0, double imagine = 0) : real(real), imagine(imagine) &#123;&#125; Complex operator +(const Complex X) &#123; return Complex(real + X.real, imagine + X.imagine); &#125; Complex operator -(const Complex X) &#123; return Complex(real - X.real, imagine - X.imagine); &#125; Complex operator *(const Complex X) &#123; return Complex(real * X.real - imagine * X.imagine, real * X.imagine + imagine * X.real); &#125;&#125;X[N + 5], Y[N + 5];void FFT(Complex *T, int n, int op)&#123; Rep(i, 0, n) if (i &lt; Rev[i]) swap(T[i], T[Rev[i]]); for (int Size = 1; Size &lt; n; Size &lt;&lt;= 1) &#123; Complex wn = Complex(cos(pi / Size), sin(pi / Size) * op); for (int L = 0; L &lt; n; L += (Size &lt;&lt; 1)) &#123; Complex w = Complex(1, 0); Rep(R, L, L + Size) &#123; Complex x = T[R], y = w * T[R + Size]; T[R] = x + y, T[R + Size] = x - y; w = w * wn; &#125; &#125; &#125;&#125;int sqz()&#123; int n = read() - 1; rep(i, 0, n) scanf(\"%lf\", &amp;X[i].real); Y[n] = 0; rep(i, 1, n) Y[n + i] = 1.0 / ((double)i * i), Y[n - i] = -1.0 / ((double)i * i); int x = 3 * n; int t, l = 0; for (t = 1; t &lt;= x; t &lt;&lt;= 1) l++; Rep(i, 0, t) Rev[i] = (Rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; l - 1); FFT(X, t, 1); FFT(Y, t, 1); Rep(i, 0, t) X[i] = X[i] * Y[i]; FFT(X, t, -1); rep(i, n, 2 * n) printf(\"%.3lf\\n\", X[i].real / t); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://yoursite.com/tags/FFT/"}]},{"title":"[BZOJ-2194]快速傅立叶之二","slug":"BZOJ-2194-快速傅立叶之二","date":"2019-01-08T14:26:54.000Z","updated":"2019-01-09T01:27:42.421Z","comments":true,"path":"2019/01/08/BZOJ-2194-快速傅立叶之二/","link":"","permalink":"http://yoursite.com/2019/01/08/BZOJ-2194-快速傅立叶之二/","excerpt":"Description 求C[k] = sigma(A[i] * B[i - k])，其中 k &lt;= i &lt; n。 n的范围是1e5。","text":"Description 求C[k] = sigma(A[i] * B[i - k])，其中 k &lt;= i &lt; n。 n的范围是1e5。 Solution 这个形式很像卷积的形式，那么我们只需要转化为卷积后再做一遍FFT即可。 我们观察后发现，如果把A数组翻转一下，那么C[k] = sigma(A[n - i] B[i - k])。 而对A和B进行卷积后得到的C’数组 C[n - k] = sigma(A[n - i] B[i - k])。 所以我们只要再把C’数组翻转一下就可以得到C数组了。 Notice 注意要2遍翻转。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = INF + 7;const int N = 264000;const double eps = 1e-6, pi = acos(-1.0);ll read()&#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;&#125;void write(ll y)&#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0');&#125;int Rev[N + 5];struct Complex&#123; double real, imagine; Complex(double real = 0, double imagine = 0) : real(real), imagine(imagine) &#123;&#125;; Complex operator +(const Complex X) &#123; return Complex(real + X.real, imagine + X.imagine); &#125; Complex operator -(const Complex X) &#123; return Complex(real - X.real, imagine - X.imagine); &#125; Complex operator *(const Complex X) &#123; return Complex(real * X.real - imagine * X.imagine, real * X.imagine + imagine * X.real); &#125;&#125;X[N + 5], Y[N + 5];void FFT(Complex *T, int n, int op)&#123; Rep(i, 0, n) if (i &lt; Rev[i]) swap(T[i], T[Rev[i]]); for (int Size = 1; Size &lt; n; Size &lt;&lt;= 1) &#123; Complex wn = Complex(cos(pi / Size), sin(pi / Size) * op); for (int L = 0; L &lt; n; L += (Size &lt;&lt; 1)) &#123; Complex w = Complex(1, 0); Rep(R, L, L + Size) &#123; Complex x = T[R], y = w * T[R + Size]; T[R] = x + y, T[R + Size] = x - y; w = w * wn; &#125; &#125; &#125;&#125;int sqz()&#123; int n = read() - 1; int x = 2 * n; rep(i, 0, n) X[n - i] = read(), Y[i] = read(); int t, l = 0; for (t = 1; t &lt;= x; t &lt;&lt;= 1) l++; Rep(i, 0, t) Rev[i] = (Rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; l - 1); FFT(X, t, 1); FFT(Y, t, 1); Rep(i, 0, t) X[i] = X[i] * Y[i]; FFT(X, t, -1); per(i, n, 0) printf(\"%d\\n\", int(X[i].real / t + 0.5)); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://yoursite.com/tags/FFT/"}]},{"title":"[BZOJ-2179]FFT快速傅立叶","slug":"BZOJ-2179-FFT快速傅立叶","date":"2019-01-08T13:45:02.000Z","updated":"2019-01-08T13:52:57.846Z","comments":true,"path":"2019/01/08/BZOJ-2179-FFT快速傅立叶/","link":"","permalink":"http://yoursite.com/2019/01/08/BZOJ-2179-FFT快速傅立叶/","excerpt":"Description 给你2个高精度数，求这两个数的乘积。","text":"Description 给你2个高精度数，求这两个数的乘积。 Solution 60000的数据范围显然我们不能用O(n ^ 2)算法来解决。 所以我们把高精度数的每一位看成是一个系数，题目就转化成了多项式相乘。 Notice 注意最后的进位。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = INF + 7;const int N = 132000;const double eps = 1e-6, pi = acos(-1.0);ll read()&#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;&#125;void write(ll y)&#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0');&#125;int T[N + 5], Rev[N + 5];char s[N + 5];struct Complex&#123; double real, imagine; Complex (double _real = 0, double _imagine = 0) &#123; real = _real, imagine = _imagine;&#125; Complex operator +(const Complex X) &#123; return Complex(real + X.real, imagine + X.imagine); &#125; Complex operator -(const Complex X) &#123; return Complex(real - X.real, imagine - X.imagine); &#125; Complex operator *(const Complex X) &#123; return Complex(real * X.real - imagine * X.imagine, real * X.imagine + imagine * X.real); &#125;&#125;X[N + 5], Y[N + 5];void FFT(Complex *T, int n, int op)&#123; Rep(i, 0, n) if (i &gt; Rev[i]) swap(T[i], T[Rev[i]]); for (int Size = 1; Size &lt; n; Size &lt;&lt;= 1) &#123; Complex wn = Complex(cos(pi / Size), sin(pi / Size) * op); for (int L = 0; L &lt; n; L += (Size &lt;&lt; 1)) &#123; Complex w = Complex(1, 0); Rep(R, L, L + Size) &#123; Complex x = T[R], y = w * T[R + Size]; T[R] = x + y, T[R + Size] = x - y; w = w * wn; &#125; &#125; &#125;&#125;int sqz()&#123; int n = read() - 1; int x = n * 2; scanf(\"%s\", s); rep(i, 0, n) X[i] = s[n - i] - '0'; scanf(\"%s\", s); rep(i, 0, n) Y[i] = s[n - i] - '0'; int t, l = 0; for (t = 1; t &lt;= x; t &lt;&lt;= 1) l++; Rep(i, 0, t) Rev[i] = (Rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; l - 1); FFT(X, t, 1); FFT(Y, t, 1); Rep(i, 0, t) X[i] = X[i] * Y[i]; FFT(X, t, -1); rep(i, 0, x) T[i] = (int)(X[i].real / t + 0.5); Rep(i, 0, x) if (T[i] &gt;= 10) &#123; T[i + 1] += T[i] / 10; T[i] %= 10; &#125; if (T[x] &gt;= 10) T[x + 1] += T[x] / 10, T[x] %= 10, x++; per(i, x, 0) printf(\"%d\", T[i]); puts(\"\"); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://yoursite.com/tags/FFT/"}]},{"title":"数学-FFT","slug":"数学-FFT","date":"2019-01-03T14:12:51.000Z","updated":"2019-01-08T13:44:21.215Z","comments":true,"path":"2019/01/03/数学-FFT/","link":"","permalink":"http://yoursite.com/2019/01/03/数学-FFT/","excerpt":"问题类型 有时候我们需要将两个多项式乘起来，如果我们采用类似高精度乘法的算法，那么时间复杂度是O(n ^ 2)的。 那么我们有没有更加优秀的时间复杂度呢？ 答案是有的。我们可以用FFT来完成多项式乘法的任务，时间复杂度是O(n * logn)的。","text":"问题类型 有时候我们需要将两个多项式乘起来，如果我们采用类似高精度乘法的算法，那么时间复杂度是O(n ^ 2)的。 那么我们有没有更加优秀的时间复杂度呢？ 答案是有的。我们可以用FFT来完成多项式乘法的任务，时间复杂度是O(n * logn)的。 解决方案前置技能多项式表达法 多项式有常见的2种表达方式： 系数表达法 所谓系数表达法，就是用 F(x) = a0 x^0 + a1 x^1 + ··· + an x^n这时候如果我们要实现多项式乘法 F[i + j] = sigma(G[i] * H[j]) （用F[i]，G[i]，H[i]表示多项式的i次方系数，G和H相乘得到F）所以这是O(n ^ 2)的时间复杂度。 点值表达法点值表示法，就是用n+1个点对 (xi, yi)来表示一个多项式（可以由高斯消元唯一确定一个n次多项式）此时如果我们相乘很显然只要O(n)的时间复杂度即可了 复数 有时我们会用到对-1开根号的结果，我们把这个结果表示成i。 我们用a+bi的形式来表示一个复数，那么这个复数可以在坐标轴上表示为(a, b)，其中a是复数的实部，b为复数的虚部。 (a + bi) * (c + di) = (ac - bd) + (ad + bc)i，我们可以发现两个虚数相乘，就是辐角相加，模长相乘。 我们称wn为n次单位根，它的n次方即为1。用w[n][k]表示wn的k次方。显然我们可以在一个单位圆上找到w[n][1]，···，w[n][k]。 单位根有一些很显然的性质：w[n][k] = w[2n][2k], w[2n][k] = -w[2n][k + n] FFT而FFT的核心内容就是DFT（将系数表达法转化为点值表达法）和IDFT（将点值表达法转化回系数表达法） DFT在DFT的过程中，我们已知多项式的系数，要根据复数的单位根求一些点值。我们发现 F(w[n][k]) = a0 * w[n][k] ^ 0 + a1 * w[n][k] ^ 1 + ··· + an-1 * w[n][k] ^ n-1F(w[n][k]) = L(w[n][k]) + w[n][k] * R(w[n][k]) （L表示以偶次幂的系数组成的多项式，R表示以奇次幂的系数组成的多项式，而R这个多项式可以提取公因子w[n][k]）而L(w[n][k])可以看成是一个变量是w[n][k] ^ 2的多项式G(w[n][k] ^ 2)，同理R(w[n][k])也可以。所以我们得到 F(w[n][k]) = G(w[n / 2][k]) + w[n][k] * H(w[n / 2][k])而G和H这两个多项式都是n / 2次的，所以我们可以通过递归来处理。 有时候我们觉得递归版的常数太大了，我们就要用到非递归版的。我们每次在往下递归的时候，把系数分成了偶次幂和奇次幂两块。所以在第i层往下递归时，放在左边的就是二进制上第i位为0的，放在右边的是二进制上第i位为1的。所以每个位置递归到最后的值，就是原来坐标把二进制翻转以后得到的坐标上的值。所以我们可以预处理出Rev数组，表示一个数二进制翻转以后得到的数。然后我们只要枚举层数，枚举起始位置，枚举要合并的位置即可。总时间复杂度还是O(n * logn)的。 IDFTIDFT的过程，就是把点值重新转化为系数表达式。有人证出来插值只要将所有w[n][k]换成w[n][k + n / 2]，也就是所有的虚部取相反数，再将最终结果除以len就行了。所以这部分的过程和DFT的过程相类似。 代码演示递归版12345678910111213141516171819202122232425void FFT(Complex *T, int n, int op)&#123; if (n == 1) return; Complex L[n &gt;&gt; 1], R[n &gt;&gt; 1]; Rep(i, 0, n &gt;&gt; 1) L[i] = T[i &lt;&lt; 1], R[i] = T[i &lt;&lt; 1 | 1]; FFT(L, n &gt;&gt; 1, op); FFT(R, n &gt;&gt; 1, op); Complex wn = Complex(cos(2.0 * pi / n), sin(2.0 * pi / n) * op); Complex w = Complex(1, 0); Rep(i, 0, n &gt;&gt; 1) &#123; T[i] = L[i] + R[i] * w, T[i + (n &gt;&gt; 1)] = L[i] - R[i] * w; w = w * wn; &#125;&#125;int main()&#123; int n = read(), m = read(); rep(i, 0, n) X[i] = read(); rep(i, 0, m) Y[i] = read(); int t; for (t = 1; t &lt;= n + m; t &lt;&lt;= 1); FFT(X, t, 1); FFT(Y, t, 1); Rep(i, 0, t) X[i] = X[i] * Y[i]; FFT(X, t, -1); rep(i, 0, n + m) printf(\"%d \", int(X[i].real / t + 0.5)); return 0;&#125; 非递归版12345678910111213141516171819202122232425262728293031void FFT(Complex *T, int n, int op)&#123; Rep(i, 0, n) if (i &lt; Rev[i]) swap(T[i], T[Rev[i]]); for (int Size = 1; Size &lt; n; Size &lt;&lt;= 1) &#123; Complex wn = Complex(cos(pi / Size), sin(pi / Size) * op); for (int L = 0; L &lt; n; L += (Size &lt;&lt; 1)) &#123; Complex w = Complex(1, 0); Rep(R, L, L + Size) &#123; Complex x = T[R], y = w * T[R + Size]; T[R] = x + y; T[R + Size] = x - y; w = w * wn; &#125; &#125; &#125;&#125;int main()&#123; int n = read(), m = read(); rep(i, 0, n) X[i] = read(); rep(i, 0, m) Y[i] = read(); int t, l = 0; for (t = 1; t &lt;= n + m; t &lt;&lt;= 1) l++; Rep(i, 0, t) Rev[i] = (Rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; l - 1); FFT(X, t, 1); FFT(Y, t, 1); Rep(i, 0, t) X[i] = X[i] * Y[i]; FFT(X, t, -1); rep(i, 0, n + m) printf(\"%d \", int(X[i].real / t + 0.5)); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"快速傅立叶变换","slug":"快速傅立叶变换","permalink":"http://yoursite.com/tags/快速傅立叶变换/"}]},{"title":"[LOJ-6000]搭配飞行员","slug":"LOJ-6000-搭配飞行员","date":"2018-09-07T11:49:27.000Z","updated":"2018-09-07T11:49:27.662Z","comments":true,"path":"2018/09/07/LOJ-6000-搭配飞行员/","link":"","permalink":"http://yoursite.com/2018/09/07/LOJ-6000-搭配飞行员/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[BZOJ-1050]旅行","slug":"BZOJ-1050-旅行","date":"2018-08-02T13:47:34.000Z","updated":"2019-01-08T13:48:24.017Z","comments":true,"path":"2018/08/02/BZOJ-1050-旅行/","link":"","permalink":"http://yoursite.com/2018/08/02/BZOJ-1050-旅行/","excerpt":"Description 给你一张n个点m条边的无向图，有两个点s和t。 询问从s到t的路径中，最大边权与最小边权的比值最小是多少。","text":"Description 给你一张n个点m条边的无向图，有两个点s和t。 询问从s到t的路径中，最大边权与最小边权的比值最小是多少。 Solution 这是一道[HAOI2006]的题。 我们可以用LCT做这道题。 我们给边按边权从小到大排序，每次加入一条边。 如果要加入的这条边的两个顶点已经联通了，就找到联通的路径上的最小边把它删掉。 然后再连上这条边。然后统计一下答案即可。 因为我们按次序枚举边，所以当前s到t路径上的最大边一定是当前边，所以我们要最小边权尽量大，所以删掉最小的边。 我们给边按边权从小到大排序后，枚举最小的边。然后像Kruskal一样做，直到s到t联通。 因为这样最小边权是确定的，想要比值小，所以要最大边权尽量小，做最小生成树即可。 Notice 我们用LCT维护路径上的最小边权和最大边权时，情况有点复杂。 CodeLCT:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = INF + 7;const int N = 5500;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int cnt = 0, Maxans = INF, Minans = 1, n, m;struct node&#123; int u, v, w;&#125;Edge[N + 5];int cmp(node X, node Y)&#123; return X.w &lt; Y.w;&#125;int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125;struct LinkCutTree&#123; int Val[N + 5], Min[N + 5], Max[N + 5], Son[N + 5][2], rev[N + 5], Stack[N + 5], Fa[N + 5], top; inline int isroot(int x) &#123; return Son[Fa[x]][0] != x &amp;&amp; Son[Fa[x]][1] != x; &#125; inline int VMin(int t) &#123; return t != -1 ? t : INF; &#125; inline int VMax(int t) &#123; return t != -1 ? t : 0; &#125; inline void up(int x) &#123; Min[x] = Max[x] = x; if (VMin(Val[Min[Son[x][0]]]) &lt; VMin(Val[Min[x]])) Min[x] = Min[Son[x][0]]; if (VMin(Val[Min[Son[x][1]]]) &lt; VMin(Val[Min[x]])) Min[x] = Min[Son[x][1]]; if (VMax(Val[Max[Son[x][0]]]) &gt; VMax(Val[Max[x]])) Max[x] = Max[Son[x][0]]; if (VMax(Val[Max[Son[x][1]]]) &gt; VMax(Val[Max[x]])) Max[x] = Max[Son[x][1]]; &#125; inline void down(int x) &#123; if (rev[x]) &#123; rev[Son[x][0]] ^= 1, rev[Son[x][1]] ^= 1, rev[x] ^= 1; swap(Son[x][0], Son[x][1]); &#125; &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y], l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y), up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int i = x; !isroot(i); i = Fa[i]) Stack[++top] = Fa[i]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[y][1] == x) ^ (Son[z][1] == y)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int x) &#123; for (int last = 0; x; last = x, x = Fa[x]) Splay(x), Son[x][1] = last, up(x); &#125; inline void Make_Root(int x) &#123; Access(x), Splay(x), rev[x] ^= 1; &#125; inline int Find_Root(int x) &#123; Access(x), Splay(x); while (Son[x][0]) x = Son[x][0]; return x; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); if (Find_Root(x) == Find_Root(y)) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); if (Find_Root(x) != Find_Root(y) || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; n = read(), m = read(); rep(i, 1, m) &#123; int x = read(), y = read(), z = read(); if (x != y) Edge[++cnt].u = x, Edge[cnt].v = y, Edge[cnt].w = z; &#125; rep(i, 0, n + cnt) LCT.Val[i] = -1, LCT.Min[i] = LCT.Max[i] = i; int s = read(), t = read(); s += cnt, t += cnt; sort(Edge + 1, Edge + cnt + 1, cmp); rep(i, 1, cnt) &#123; int u = Edge[i].u + cnt, v = Edge[i].v + cnt; LCT.Val[i] = Edge[i].w; if (LCT.Find_Root(u) == LCT.Find_Root(v)) &#123; LCT.Split(u, v); int t = LCT.Min[v]; LCT.Cut(Edge[t].u + cnt, t); LCT.Cut(Edge[t].v + cnt, t); &#125; LCT.Link(u, i); LCT.Link(v, i); if (LCT.Find_Root(s) != LCT.Find_Root(t)) continue; LCT.Split(s, t); if ((double)LCT.Val[LCT.Max[t]] / LCT.Val[LCT.Min[t]] &lt; (double)Maxans / Minans) Maxans = LCT.Val[LCT.Max[t]], Minans = LCT.Val[LCT.Min[t]]; &#125; int g = gcd(Maxans, Minans); Maxans /= g, Minans /= g; if (Maxans == INF) puts(\"IMPOSSIBLE\"); else if (Minans == 1) printf(\"%d\\n\", Maxans); else printf(\"%d/%d\\n\", Maxans, Minans); return 0;&#125; 最小生成树:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//// BZOJ-1050.cpp// 图论/最小生成树//// Created by 沈擎舟 on 2018/8/2.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = INF + 7;const int N = 5500;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int Fa[N + 5];int Maxans = INF, Minans = 1;struct node&#123; int u, v, w;&#125;Edge[N + 5];int cmp(node X, node Y)&#123; return X.w &lt; Y.w;&#125;int Find(int x)&#123; return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);&#125;int gcd(int x, int y)&#123; return y ? gcd(y, x % y) : x;&#125;int sqz()&#123; int n = read(), m = read(); rep(i, 1, m) Edge[i].u = read(), Edge[i].v = read(), Edge[i].w = read(); sort(Edge + 1, Edge + m + 1, cmp); int s = read(), t = read(); rep(i, 1, m) &#123; rep(j, 1, n) Fa[j] = j; rep(j, i, m) &#123; int fx = Find(Edge[j].u), fy = Find(Edge[j].v); if (fx != fy) Fa[fx] = fy; if (Find(s) == Find(t)) &#123; if ((double)Edge[j].w / Edge[i].w &lt; (double)Maxans / Minans) Maxans = Edge[j].w, Minans = Edge[i].w; break; &#125; &#125; &#125; int g = gcd(Maxans, Minans); Maxans /= g, Minans /= g; if (Maxans == INF) puts(\"IMPOSSIBLE\"); else if (Minans == 1) printf(\"%d\\n\", Maxans); else printf(\"%d/%d\\n\", Maxans, Minans); return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"}]},{"title":"[BZOJ-1854]游戏","slug":"BZOJ-1854-游戏","date":"2018-06-28T13:56:44.000Z","updated":"2019-01-08T13:49:27.344Z","comments":true,"path":"2018/06/28/BZOJ-1854-游戏/","link":"","permalink":"http://yoursite.com/2018/06/28/BZOJ-1854-游戏/","excerpt":"Description 给你n样物品，每个物品可以有两个属性a，b。 你要给每个物品挑选一个属性，使得跳出的属性之组成的数列从1开始连续的数字个数最多。","text":"Description 给你n样物品，每个物品可以有两个属性a，b。 你要给每个物品挑选一个属性，使得跳出的属性之组成的数列从1开始连续的数字个数最多。 Solution 这是一道[SCOI2010]的题。 因为每个物品需要2选1，所以我们想到用二分图来做。 物品i有属性a，b，那我们就给Xa -&gt; Yi, Xb -&gt; Yi连边。 然后我们枚举连续属性的最大值，给这个点找增广路，如果找不到就说明这个属性无法到达了。 这道题还有一个很妙的并查集做法。 如果一个物品有属性a，b，那么我们给a -&gt; b连一条边。 然后我们发现对于每个大小为p的联通块，如果没有环，那么可以选p-1个（不选最大的） 如果一个大小为p的联通块，含有环，那么我们这p个都可以选。 所以我们每次用并查集合并两个联通块，还要记录一个vis值，表示最大的能不能被选。 每次合并时，把属性小的合并到属性大的。如果属性小的已经和属性大的一个集合了，就把整个并查集的vis置为1。 否则，如果属性小所在集合的vis已经为1了，那么就把属性大所在集合的vis置为1，否则属性小所在集合的vis置为1。 最后从小到大扫到vis为0时输出就好了 Notice 没什么需要注意的。 Code用二分图最大匹配解决：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 1000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int head[N + 5], flag[N + 5], match[N + 5];int edgenum = 0, ans, T = 0;struct node&#123; int vet, next;&#125;edge[2 * N + 5];void addedge(int u, int v)&#123; edge[edgenum].vet = v; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int Hungarian(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; if (flag[v] == ans) continue; flag[v] = ans; if (!match[v] || Hungarian(match[v])) &#123; match[v] = u; return 1; &#125; &#125; return 0;&#125;int sqz()&#123; int n = read(); rep(i, 1, 10000) head[i] = -1; rep(i, 1, n) &#123; int a = read(), b = read(); addedge(a, i), addedge(b, i); T = max(T, max(a, b)); &#125; for (ans = 1; ; ans++) if (ans &gt; T || !Hungarian(ans)) &#123; printf(\"%d\\n\", --ans); return 0; &#125; return 0;&#125; 用并查集来解决：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 1000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int vis[N + 5], Fa[N + 5];int Find(int x)&#123; return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);&#125;int sqz()&#123; int n = read(); rep(i, 1, n + 1) Fa[i] = i; rep(i, 1, n) &#123; int fx = Find(read()), fy = Find(read()); if (fx == fy) vis[fx] = 1; else &#123; if (fx &gt; fy) swap(fx, fy); if (!vis[fx]) vis[fx] = 1; else vis[fy] = 1; Fa[fx] = fy; &#125; &#125; rep(i, 1, n + 1) if (!vis[i]) &#123; printf(\"%d\\n\", i - 1); return 0; &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/二分图/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"[BZOJ-1059]矩阵游戏","slug":"BZOJ-1059-矩阵游戏","date":"2018-06-28T09:42:35.000Z","updated":"2019-01-08T13:48:39.418Z","comments":true,"path":"2018/06/28/BZOJ-1059-矩阵游戏/","link":"","permalink":"http://yoursite.com/2018/06/28/BZOJ-1059-矩阵游戏/","excerpt":"Description 给你一个01矩阵，你每次操作可以交换两行或者交换两列。 问你是否能得到一个矩阵使得矩阵的主对角线（左上角到右下角的连线）都为1。","text":"Description 给你一个01矩阵，你每次操作可以交换两行或者交换两列。 问你是否能得到一个矩阵使得矩阵的主对角线（左上角到右下角的连线）都为1。 Solution 这是一道[ZJOI2007]的题。 因为同行同列的点，变化后仍然是同行同列的。 因为对角线都是不同行不同列的，所以我们只要找不同行同列的是否到了n个就可以了。 如果原矩阵中第i行第j列为1，那么就Xi -&gt; Yj连一条边。然后跑最大匹配即可。 Notice 因为有多组数据，千万要记得每次对match数组清零。 Code匈牙利算法版本：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 200;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int head[N + 5], vis[N + 5], match[N + 5];int edgenum = 0;struct node&#123; int vet, next;&#125;edge[N * N + 5];void addedge(int u, int v)&#123; edge[edgenum].vet = v; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int Find(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; if (vis[v]) continue; vis[v] = 1; if (!match[v] || Find(match[v])) &#123; match[v] = u; return 1; &#125; &#125; return 0;&#125;int sqz()&#123; int H_H = read(); while (H_H--) &#123; int n = read(); int ans = 0; edgenum = 0; rep(i, 1, n) head[i] = -1, match[i] = 0; rep(i, 1, n) rep(j, 1, n) &#123; int x = read(); if (x) addedge(i, j); &#125; rep(i, 1, n) &#123; rep(j, 1, n) vis[j] = 0; if (Find(i)) ans++; &#125; if (ans == n) puts(\"Yes\"); else puts(\"No\"); &#125; return 0;&#125; Hopcroft-Karp算法版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 200;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int head[N + 5], vis[N + 5], Matchx[N + 5], Matchy[N + 5], Disx[N + 5], Disy[N + 5];int edgenum = 0, n, Dis;struct node&#123; int vet, next;&#125;edge[N * N + 5];void addedge(int u, int v)&#123; edge[edgenum].vet = v; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;queue&lt;int&gt; Q;int bfs()&#123; rep(i, 1, n) &#123; Disx[i] = Disy[i] = -1; if (!Matchx[i]) Q.push(i), Disx[i] = 0; &#125; Dis = INF; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); if (Disx[u] &gt; Dis) continue; travel(i, u) &#123; int v = edge[i].vet; if (~Disy[v]) continue; Disy[v] = Disx[u] + 1; if (!Matchy[v]) Dis = Disy[v]; else &#123; Disx[Matchy[v]] = Disy[v] + 1; Q.push(Matchy[v]); &#125; &#125; &#125; return Dis != INF;&#125;int dfs(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; if (!vis[v] &amp;&amp; Disy[v] == Disx[u] + 1) &#123; vis[v] = 1; if (!Matchy[v] || dfs(Matchy[v])) &#123; Matchy[v] = u, Matchx[u] = v; return 1; &#125; &#125; &#125; return 0;&#125;int MaxMatch()&#123; int Match = 0; while (bfs()) &#123; rep(i, 1, n) vis[i] = 0; rep(i, 1, n) if (!Matchx[i]) Match += dfs(i); &#125; return Match;&#125;int sqz()&#123; int H_H = read(); while (H_H--) &#123; n = read(); int ans = 0; edgenum = 0; rep(i, 1, n) head[i] = -1, Matchx[i] = Matchy[i] = 0; rep(i, 1, n) rep(j, 1, n) &#123; int x = read(); if (x) addedge(i, j); &#125; if (MaxMatch() == n) puts(\"Yes\"); else puts(\"No\"); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/二分图/"}]},{"title":"图论-二分图(1)","slug":"图论-二分图-1","date":"2018-06-27T12:17:36.000Z","updated":"2018-07-26T12:24:48.909Z","comments":true,"path":"2018/06/27/图论-二分图-1/","link":"","permalink":"http://yoursite.com/2018/06/27/图论-二分图-1/","excerpt":"问题类型 如果一个图的点集可以分为两部分，且所有边的两个端点都在不同的部分中，则这个图是一个二分图。 有很多关于多选一的问题都可以建模成二分图来解决。 这里我们先讲关于二分图最大匹配的问题。","text":"问题类型 如果一个图的点集可以分为两部分，且所有边的两个端点都在不同的部分中，则这个图是一个二分图。 有很多关于多选一的问题都可以建模成二分图来解决。 这里我们先讲关于二分图最大匹配的问题。 解决方案 首先我们来了解一些定义： 1.点覆盖集：即一个点集，使得所有边至少有一个端点在集合里。（“点”覆盖了所有“边”） 2.边覆盖集：即一个边集，使得所有点都与集合里的边邻接。（“边” 覆盖了所有“点”） 3.点独立集：即一个点集，满足集合中任两个结点不相邻。（导出的子图是零图（没有边）的点集） 4.边独立集：即一个边集，满足边集中的任两边不邻接。（就是匹配） 5.点支配集：即一个点集，使得所有其他点至少有一个相邻点在集合里。（一部分的“点”支配了所有“点”）。 6.边支配集：即一个边集，使得所有边至少有一条邻接边在集合里。（一部分的“边”支配了所有“边”）。 7.DAG的最小路径覆盖：是“路径” 覆盖“点”，即用尽量少的不相交简单路径覆盖有向无环图G的所有顶点，每个顶点严格属于一条路径。路径的长度可能为0(单个点)。 在二分图中，有以下性质： 1.最大匹配数 = 最大边独立数。 2.最大边独立数 = 最小点覆盖数 = 最大匹配数。 3.最大点独立数 = 最小边覆盖数 = n(节点个数) - 最大匹配数。 4.一个DAG的最小路径覆盖 = n(节点个数) - 转化为二分图后的最大匹配数 证明： 1.由定义即可知：最大匹配数 = 最大边独立数。 2.我们对最大匹配的每对匹配边都选取一个点出来组成点覆盖集。 证最小点覆盖≤最大匹配：如果仍有一些边未被这个集合覆盖，那么就说明匹配里可以加上这些未被覆盖的边，这就不是最大匹配了。 证最小点覆盖≥最大匹配：如果最大匹配里有一条边的两个点都不选，那么这条边就未被覆盖，不符合点覆盖的定义。 所以 最大边独立数 = 最小点覆盖数 = 最大匹配数。 3.我们先证明 最大点独立数 = n - 最大匹配数 最大点独立集其实就是最小点覆盖集关于整个二分图点集的补集。 先证明这是个点独立集：这些点之间如果还有边使独立集中两点相邻，则这条边就没被最小点覆盖集“覆盖”到，矛盾。 再证明这是个最大的点独立集：如果还能再加入点，这个点必定是最小点覆盖集中的一个点，而必定会有一条边联通这个点和原来的这个点独立集中的点，不符合点独立集定义。 所以就有 最大点独立数 = n - 最大匹配数。 我们再来证明 最小边覆盖 = n - 最大匹配数 假设最大匹配数为k。 我们贪心的考虑尽量用边去覆盖多的点，所以我们先把最大匹配都选了，已选k条边。 剩下n - 2 k个点都用一条边去覆盖，所以总共选了n - 2 k + k = n - k。 所以 最小边覆盖 = n - 最大匹配数。 4.我们先讲一下如何把一个DAG转化为一个二分图。 如果在DAG上u -&gt; v有一条边，那我们在二分图上Xu -&gt; Yv连一条边。 因为DAG的最小路径覆盖要求不能相交，所以每一个点最多只会有一个后继。 所以我们求出最大匹配后，那些在匹配里的就是有后继的节点，所以会有(n - 最大匹配数)个点没有后继节点。 又因为一条路径只会有一个点也就是最后一个点没有后继节点，所以 一个DAG的最小路径覆盖 = n - 转化为二分图后的最大匹配数。 有了以上性质，很多问题都可以转化为求二分图的最大匹配。接下来我们来讲讲如何求一个二分图的最大匹配。 所有求最大匹配的算法都是基于增广路定理的：一个匹配是最大匹配当且仅当没有增广路。这个定理适用于任意图。 我们先来讲一讲增广路的定义：增广路是一条起点为未匹配点，终点为未匹配点，且相邻两条边肯定满足一条在匹配里，一条不在匹配里的路径。 所以增广路有以下性质： 1.有奇数条边，有偶数个点。 2.起点在二分图的左半边，终点在右半边（一个左半边，一个右半边）。 3.路径上的点一定是一个在左半边，一个在右半边，交替出现。 4.整条路径上没有重复的点。 5.起点和终点都是目前还没有配对的点，而其它所有点都是已经配好对的。 6.路径上的所有第奇数条边都不在原匹配中，所有第偶数条边都出现在原匹配中。 7.把增广路径上的所有第奇数条边加入到原匹配中去，并把增广路径中的所有第偶数条边从原匹配中删除（这个操作称为增广路径的取反），则新的匹配数就比原匹配数多了1个。（求最大匹配的关键） 我们先来讲讲用匈牙利算法求二分图的最大匹配： 我们先给每个点都置为未匹配。每次我们都寻找到一条增广路的时候，答案+1即可。 那么如何寻找增广路呢？ 我们先从随意一个未被匹配的点开始找起，遍历它的出边u -&gt; v。 如果v没有匹配或者可以从v的匹配开始继续找到增广路（递归实现）那么就把v的匹配改成u（给匹配取反）。 因为增广路不能相交，所以一个点在同一个寻找增广路的过程中被扫过多次就没有意义了。用数组标记以下即可。 所以每次寻找增广路时间复杂度为O(m)。又因为最大匹配不超过n，即最多找n次增广路，所以总时间复杂度为O(n * m)。 Hopcroft-Karp算法就是对匈牙利算法进行了优化：匈牙利是每次找一条增广路，Hopcroft-Karp是每次找多条增广路。 我们用bfs来寻找还有没有增广路，顺便处理一个点到X点集中还未匹配过的点的最短距离。 所以我们dfs增广的时候只要对dis[v] = dis[u] + 1的边进行增广就可以了。 算法流程类似下图： 其中红色边为增广路，黄色边为已匹配的边。 好像可以证明时间复杂度是O(n ^ 0.5 * m)（但我不会啊） 代码演示 匈牙利算法的代码：12345678910111213141516171819202122232425int Find(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; if (vis[v]) continue; vis[v] = 1; if (!match[v] || Find(match[v])) &#123; match[v] = u; return 1; &#125; &#125; return 0;&#125;int main()&#123; Init(); rep(i, 1, n) &#123; if (match[i]) continue; rep(j, 1, n) vis[j] = 0; if (Find(i)) ans++; &#125;&#125; Hopcroft-Karp算法的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int bfs()&#123; rep(i, 1, n) &#123; Disx[i] = Disy[i] = -1; if (!Matchx[i]) Q.push(i), Disx[i] = 0; &#125; Dis = INF; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); if (Disx[u] &gt; Dis) continue; travel(i, u) &#123; int v = edge[i].vet; if (~Disy[v]) continue; Disy[v] = Disx[u] + 1; if (!Matchy[v]) Dis = Disy[v]; else &#123; Disx[Matchy[v]] = Disy[v] + 1; Q.push(Matchy[v]); &#125; &#125; &#125; return Dis != INF;&#125;int dfs(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; if (!vis[v] &amp;&amp; Disy[v] == Disx[u] + 1) &#123; vis[v] = 1; if (!Matchy[v] || dfs(Matchy[v])) &#123; Matchy[v] = u, Matchx[u] = v; return 1; &#125; &#125; &#125; return 0;&#125;int MaxMatch()&#123; int Match = 0; while (bfs()) &#123; rep(i, 1, n) vis[i] = 0; rep(i, 1, n) if (!Matchx[i]) Match += dfs(i); &#125; return Match;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/二分图/"}]},{"title":"[HDU-1232]畅通工程","slug":"HDU-1232-畅通工程","date":"2018-06-26T11:30:50.000Z","updated":"2019-01-08T13:51:25.864Z","comments":true,"path":"2018/06/26/HDU-1232-畅通工程/","link":"","permalink":"http://yoursite.com/2018/06/26/HDU-1232-畅通工程/","excerpt":"Description 给你一张图，问至少还要连几条边才能使得整个图都联通。","text":"Description 给你一张图，问至少还要连几条边才能使得整个图都联通。 Solution 我们只要用并查集统计联通块个数即可，然后答案就是n - 1 - 联通块个数。 Notice 注意多组数据和初始化。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 30000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;char st[5];int n = 0, now = 0;struct UnionFindSet&#123; int Fa[N + 5], Rank[N + 5]; void Make_Set(int x) &#123; Fa[x] = x, Rank[x] = 0; &#125; int Find(int x) &#123; return Fa[x] == x ? x : Fa[x] = Find(Fa[x]); &#125; void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if (fx == fy) return; now++; if (Rank[fx] &lt; Rank[fy]) Fa[fx] = fy; else Fa[fy] = fx; if (Rank[fx] == Rank[fy]) Rank[fx]++; &#125;&#125;UFS;int sqz()&#123; while (~scanf(\"%d\", &amp;n)) &#123; if (!n) break; int m = read(); now = 0; rep(i, 1, n) UFS.Make_Set(i); while (m--) &#123; int x = read(), y = read(); UFS.Union(x, y); &#125; printf(\"%d\\n\", n - 1 - now); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"图论-并查集","slug":"图论-并查集","date":"2018-06-25T11:54:09.000Z","updated":"2018-07-25T15:58:59.376Z","comments":true,"path":"2018/06/25/图论-并查集/","link":"","permalink":"http://yoursite.com/2018/06/25/图论-并查集/","excerpt":"问题类型 在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 这时我们就需要用到并查集了。","text":"问题类型 在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 这时我们就需要用到并查集了。 解决方案 在并查集中，我们要支持Union(合并)和Find(查找)操作。其中Union就是把x和y所在集合合并，Find就是查找x所在集合的代表元素。 我们在并查集中记录Fa数组，我们每次Find只要一直向上找父亲就可以了。Union只要找到x的祖先和y的祖先，然后令Fa[x] = y 就行了。 我们对并查集有两个优化： 1: 按秩合并 我们引出秩的概念，我们用秩的相对大小来表示树的相对大小（实际上就是高度） 因为我们想通过让树的深度尽量小来优化时间复杂度，所以我们合并的时候把秩小的合并到秩大的。 2: 路径压缩 我们每次都要查询一个点的祖先，而每次向上查找显然是不优的。 所以我们每次查询的同时，直接把Fa[x]改为x的祖先。 代码演示1234567891011121314151617181920struct UnionFindSet&#123; int Fa[N + 5], Rank[N + 5]; void Make_Set(int x) &#123; Fa[x] = x, Rank[x] = 0; &#125; int Find(int x) &#123; return Fa[x] == x ? x : Fa[x] = Find(Fa[x]); &#125; void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if (fx == fy) return; if (Rank[fx] &lt; Rank[fy]) Fa[fx] = fy; else Fa[fy] = fx; if (Rank[fx] == Rank[fy]) Rank[fx]++; &#125;&#125;UFS;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"[BZOJ-3436]小K的农场","slug":"BZOJ-3436-小K的农场","date":"2018-06-25T10:27:13.000Z","updated":"2019-01-08T13:50:58.862Z","comments":true,"path":"2018/06/25/BZOJ-3436-小K的农场/","link":"","permalink":"http://yoursite.com/2018/06/25/BZOJ-3436-小K的农场/","excerpt":"Description 有n个农场，m个条件。 1 a b c 表示农场a比农场b至少多种植了c个单位的作物。 2 a b c 表示农场a比农场b至多多种植了c个单位的作物。 3 a b 表示农场a与农场b种植的作物数一样多。 询问存不存在一组合法解。","text":"Description 有n个农场，m个条件。 1 a b c 表示农场a比农场b至少多种植了c个单位的作物。 2 a b c 表示农场a比农场b至多多种植了c个单位的作物。 3 a b 表示农场a与农场b种植的作物数一样多。 询问存不存在一组合法解。 Solution 差分约束系统，把图建出来以后跑最长路，判一下有没有正环就行了。 Notice 因为0要连边，所以要多开几倍边。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 30005;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int head[N + 5], Dis[N + 5], Flag[N + 5], Q[N + 5], Vis[N + 5];int edgenum = 0, n, m, k;ll ans;struct node&#123; int vet, next, val;&#125;edge[3 * N + 5];void addedge(int u, int v, int w)&#123; edge[edgenum].vet = v; edge[edgenum].val = w; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int spfa()&#123; int Head = 0, Tail = 1; Q[0] = 0, Flag[0] = 1, Vis[0] = 1, Dis[0] = 0; while (Head != Tail) &#123; int u = Q[Head]; Head = (Head + 1) % N; travel(i, u) &#123; int v = edge[i].vet; if (Dis[u] + edge[i].val &gt; Dis[v]) &#123; Dis[v] = Dis[u] + edge[i].val; if (++Vis[v] &gt;= n) return 0; if (!Flag[v]) &#123; Q[Tail] = v, Flag[v] = 1; Tail = (Tail + 1) % N; &#125; &#125; &#125; Flag[u] = 0; &#125; return 1;&#125;int sqz()&#123; n = read(), m = read(); rep(i, 0, n) head[i] = -1, Dis[i] = -INF, Flag[i] = 0; rep(i, 1, m) &#123; int op = read(); if (op == 1) &#123; int a = read(), b = read(), c = read(); if (a == b) &#123; puts(\"No\"); return 0; &#125; addedge(b, a, c); &#125; if (op == 2) &#123; int a = read(), b = read(), c = read(); if (a == b) &#123; puts(\"No\"); return 0; &#125; addedge(a, b, -c); &#125; if (op == 3) &#123; int a = read(), b = read(); addedge(a, b, 0), addedge(b, a, 0); &#125; &#125; rep(i, 1, n) addedge(0, i, 0); if (!spfa()) puts(\"No\"); else puts(\"Yes\"); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"[BZOJ-2330]糖果","slug":"BZOJ-2330-糖果","date":"2018-06-24T13:59:28.000Z","updated":"2019-01-08T13:50:21.362Z","comments":true,"path":"2018/06/24/BZOJ-2330-糖果/","link":"","permalink":"http://yoursite.com/2018/06/24/BZOJ-2330-糖果/","excerpt":"Description 有n个人，每个人会被分到一些糖果。 有m对关于两个人分到的糖果个数的限制关系。 求所有人获得糖果总数的最小值。","text":"Description 有n个人，每个人会被分到一些糖果。 有m对关于两个人分到的糖果个数的限制关系。 求所有人获得糖果总数的最小值。 Solution 这是一道[SCOI2011]的题。 用差分约束系统做，跑一遍最长路就可以了。 Notice 对0加边的时候，如果正序加边的话好像会TLE，所以要倒序加边。 注意要判断无解的情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 100001;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int head[N + 5], Dis[N + 5], Flag[N + 5], Q[N + 5], Vis[N + 5];int edgenum = 0, n, k;ll ans;struct node&#123; int vet, next, val;&#125;edge[3 * N + 5];void addedge(int u, int v, int w)&#123; edge[edgenum].vet = v; edge[edgenum].val = w; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int spfa()&#123; int Head = 0, Tail = 1; Q[Head] = 0; Flag[0] = 1; Vis[0] = 1; while (Head != Tail) &#123; int u = Q[Head]; Head = (Head + 1) % N; Flag[u] = 0; travel(i, u) &#123; int v = edge[i].vet; if (Dis[u] + edge[i].val &gt; Dis[v]) &#123; Dis[v] = Dis[u] + edge[i].val; if (++Vis[v] &gt;= n) return 0; if (!Flag[v]) &#123; Q[Tail] = v; Flag[v] = 1; Tail = (Tail + 1) % N; &#125; &#125; &#125; &#125; return 1;&#125;int sqz()&#123; n = read(), k = read(), ans = 0; rep(i, 0, n) head[i] = -1; rep(i, 1, k) &#123; int op = read(), x = read(), y = read(); if ((op == 2 || op == 4) &amp;&amp; x == y) &#123; puts(\"-1\"); return 0; &#125; if (op == 1) addedge(x, y, 0), addedge(y, x, 0); if (op == 2) addedge(x, y, 1); if (op == 3) addedge(y, x, 0); if (op == 4) addedge(y, x, 1); if (op == 5) addedge(x, y, 0); &#125; per(i, n, 1) addedge(0, i, 1); if (!spfa()) &#123; puts(\"-1\"); return 0; &#125; rep(i, 1, n) ans += Dis[i]; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"图论-最短路","slug":"图论-最短路","date":"2018-06-24T11:36:29.000Z","updated":"2018-07-18T14:03:49.306Z","comments":true,"path":"2018/06/24/图论-最短路/","link":"","permalink":"http://yoursite.com/2018/06/24/图论-最短路/","excerpt":"问题类型 有时我们需要在一张图上求一个点到另外一个点的最短距离，这时就要用到最短路算法了。","text":"问题类型 有时我们需要在一张图上求一个点到另外一个点的最短距离，这时就要用到最短路算法了。 解决方案 假设我们已经有了一张n个点，m条边的图，我们要求s到t的最短路。 我们称s为源点，t为汇点，多源最短路即为有多个源点，单源最短路即为只有一个源点。 Floyd: 比较适用于多源最短路的情况。 我们用F[k][i][j]表示经过前k个点，从i到j的最短路。 所以F[k][i][j] = min(F[k - 1][i][j], F[k - 1][i][k] + F[k - 1][k][j]) 然后我们发现第一维可以被滚动掉，但我们仍要先枚举k，在枚举i，j。 时间复杂度为O(n ^ 3)。 Dijkstra: 适用于单源最短路的问题。 如果我们有一条u -&gt; v的长度为w的边，且Dis[u] + w &lt; Dis[v] 那么我们从s -&gt; u -&gt; v的路径肯定比s -&gt; v的路径优，所以我们更新Dis[v]的值。 我们把这个操作称为松弛操作。Dijkstra就是基于松弛操作的一个最短路算法。 我们对每个点都要松弛。我们每次找个Dis最小且未松弛过出边的点u，然后对它的出边进行松弛。 以上找点u的过程可以用堆来实现。时间复杂度为O(mlogm)。 SPFA: 适用于单源最短路的问题。 SPFA是Bellman-Ford的队列优化算法，也是基于松弛操作的。 我们每次对队列的队首元素u松弛它的出边(u,v)，如果被松弛了且v不在队列里，就把v加入队列。 时间复杂度为O(k*m)，k的最大值会被卡到n，但通常情况下平均值为2。 我们还可以对SPFA算法进行优化：SLF和LLL。 SLF: Small Label First，即我们在把v加入队列的时候，如果Dis[v] &lt; Dis[队首]则加到队首，否则加到队尾。 LLL: Large Label Last，我们每次在取出队首元素的时候判断一下，如果Dis[队首] &gt; 队列内Dis值的平均值，就把队首放入队尾，继续取出下一个队首。 SPFA还可以用来判负环，只要一个点进入队列&gt;=n次，原图中就有负环。 最短路算法还可以用来解决差分约束系统的问题。 我们有n个变量，m个不等式，我们对于每个形如a - b ≥ c建一条b -&gt; a的权值为c的边。 再新建一个超级源点，然后向每个点都连一条0的边。 然后我们对于这张有向图跑最长路，得到的Dis即为一组合法解。如果有正环则说明无解。 代码演示Floyd12345678void Floyd()&#123; rep(i, 1, n) F[i][i] = 0; rep(k, 1, n) rep(i, 1, n) rep(j, 1, n) F[i][j] = min(F[i][j], F[i][k] + F[k][j]);&#125; Dijkstra + Heap123456789101112131415161718192021priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; Q;void Dijkstra(int s)&#123; rep(i, 1, n) Dis[i] = INF, vis[i] = 0; Q.push(make_pair(0, s)); Dis[s] = 0; while (!Q.empty()) &#123; int u = Q.top().second; Q.pop(); if (vis[u]) continue; vis[u] = 1; travel(i, u) &#123; int v = edge[i].vet; if (!vis[v] &amp;&amp; Dis[v] &gt; Dis[u] + edge[i].val) &#123; Dis[v] = Dis[u] + edge[i].val; Q.push(make_pair(Dis[v], v)); &#125; &#125; &#125;&#125; SPFA1234567891011121314151617181920212223242526272829void SPFA(int s)&#123; int sum = 0, now = 1; rep(i, 1, n) vis[i] = 0, Dis[i] = INF; vis[s] = 1, Dis[s] = 0; Q.push_back(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop_front(); if (Dis[u] * now &gt; sum) //LLL &#123; Q.push_back(u); continue; &#125; sum -= Dis[u], now--; vis[u] = 0; travel(i, u) &#123; int v = edge[i].vet; if (Dis[v] &gt; Dis[u] + edge[i].val) &#123; Dis[v] = Dis[u] + edge[i].val; if (vis[v]) continue; if (Q.empty() || Dis[v] &gt; Dis[Q.front()]) Q.push_back(v); //SLF else Q.push_front(v); sum += Dis[v], now++; vis[v] = 1; &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"[BZOJ-3751]解方程","slug":"BZOJ-3751-解方程","date":"2018-06-23T00:37:52.000Z","updated":"2019-01-08T13:51:19.390Z","comments":true,"path":"2018/06/23/BZOJ-3751-解方程/","link":"","permalink":"http://yoursite.com/2018/06/23/BZOJ-3751-解方程/","excerpt":"Description 已知多项式方程： a0+a1x+a2x^2+…+an*x^n=0 求这个方程在[1,m]内的整数解（n和m均为正整数）。 ai ≤ 10^10000","text":"Description 已知多项式方程： a0+a1x+a2x^2+…+an*x^n=0 求这个方程在[1,m]内的整数解（n和m均为正整数）。 ai ≤ 10^10000 Solution 这是一道[NOIP2014]的题。 显然无法直接做，所以我们要用到hash的思想。 我们选取几个素数，如果一个数x在模这些素数意义下都使方程成立，那我们就认为这是方程的一个解。 Notice 注意ai的范围。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 100, M = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int X[6][N + 5], Prime[6] = &#123;0, 11261, 14843, 19997, 21893, 22877&#125;, F[6][M + 5], Ans[M + 5];int n, m, num = 5, ans = 0;char st[M + 5];int Calc(int x, int cnt)&#123; int now = X[cnt][0], mi = 1; rep(i, 1, n) &#123; mi = mi * x % Prime[cnt]; now = (now + X[cnt][i] * mi) % Prime[cnt]; &#125; return now == 0;&#125;int sqz()&#123; n = read(), m = read(); rep(i, 0, n) &#123; scanf(\"%s\", st); int len = strlen(st), flag; if (st[0] == '-') flag = 0; else flag = st[0] - '0'; rep(j, 1, num) &#123; X[j][i] = flag; Rep(k, 1, len) X[j][i] = (X[j][i] * 10 + st[k] - '0') % Prime[j]; if (!flag) X[j][i] = -X[j][i]; &#125; &#125; rep(i, 1, num) Rep(j, 0, Prime[i]) F[i][j] = Calc(j, i); rep(i, 1, m) &#123; int flag = 1; rep(j, 1, num) if (!F[j][i % Prime[j]]) &#123; flag = 0; break; &#125; if (flag) Ans[++ans] = i; &#125; printf(\"%d\\n\", ans); rep(i, 1, ans) printf(\"%d\\n\", Ans[i]); return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-2456]mode","slug":"BZOJ-2456-mode","date":"2018-06-22T07:42:15.000Z","updated":"2019-01-08T13:50:26.912Z","comments":true,"path":"2018/06/22/BZOJ-2456-mode/","link":"","permalink":"http://yoursite.com/2018/06/22/BZOJ-2456-mode/","excerpt":"Description 给你一个n个数的数列，其中某个数出现了超过n / 2次即众数，请你找出那个数。 注意：空间限制1MB。","text":"Description 给你一个n个数的数列，其中某个数出现了超过n / 2次即众数，请你找出那个数。 注意：空间限制1MB。 Solution 如果没有空间限制，我们排个序就可以了。 因为题目保证了众数的个数大于n / 2，所以我们把每个数和一个与它不同的数相抵消，最后剩下的就是答案。 Notice 注意空间限制。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int sqz()&#123; int n = read(), ans = 0, cnt = 0, x; rep(i, 1, n) &#123; x = read(); if (x == ans) cnt++; else if (cnt) cnt--; else ans = x, cnt = 1; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-2463]谁能赢呢？","slug":"BZOJ-2463-谁能赢呢？","date":"2018-06-22T07:35:18.000Z","updated":"2019-01-08T13:50:36.514Z","comments":true,"path":"2018/06/22/BZOJ-2463-谁能赢呢？/","link":"","permalink":"http://yoursite.com/2018/06/22/BZOJ-2463-谁能赢呢？/","excerpt":"Description 有一个n*n的棋盘，左上角有一个棋子。有两个人轮流移动棋子。若一个玩家无法移动则输。 每次都可以把棋子移动到它的上，下，左，右位置。求是先手必胜还是后手必胜。","text":"Description 有一个n*n的棋盘，左上角有一个棋子。有两个人轮流移动棋子。若一个玩家无法移动则输。 每次都可以把棋子移动到它的上，下，左，右位置。求是先手必胜还是后手必胜。 Solution 如果n*n是奇数，则先手必胜，否则后手必胜。 Notice 没什么需要注意的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n;int sqz()&#123; while (~scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; if (n &amp; 1) puts(\"Bob\"); else puts(\"Alice\"); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"博弈","slug":"博弈","permalink":"http://yoursite.com/tags/博弈/"}]},{"title":"[BZOJ-3289]Mato的文件管理","slug":"BZOJ-3289-Mato的文件管理","date":"2018-06-22T05:08:49.000Z","updated":"2019-01-08T13:50:51.854Z","comments":true,"path":"2018/06/22/BZOJ-3289-Mato的文件管理/","link":"","permalink":"http://yoursite.com/2018/06/22/BZOJ-3289-Mato的文件管理/","excerpt":"Description 给你n个数，每次询问对于区间[L,R]，如果每次只能交换相邻两个数，要交换多少次才能使区间内的数从小到大有序。","text":"Description 给你n个数，每次询问对于区间[L,R]，如果每次只能交换相邻两个数，要交换多少次才能使区间内的数从小到大有序。 Solution 区间[L,R]的交换次数即为[L,R]的逆序对个数。 所以我们考虑如何求区间逆序对。 我们使用莫队和数状数组。 每次加入一个数，答案就加上这个数产生的贡献。 每次删除一个数，答案就减去这个数产生的贡献。 Notice 注意要开long long。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int Belong[N + 5], Y[N + 5];ll Ans[N + 5];int cnt = 0;ll ans;struct node1&#123; int val, id;&#125;X[N + 5];int cmp1(node1 X, node1 Y)&#123; return X.val &lt; Y.val;&#125;struct node2&#123; int l, r, id;&#125;Q[N + 5];int cmp2(node2 X, node2 Y)&#123; return Belong[X.l] == Belong[Y.l] ? X.r &lt; Y.r : Belong[X.l] &lt; Belong[Y.l];&#125;struct BinaryIndexedTree&#123; int T[N + 5]; inline int lowbit(int x) &#123; return ((x) &amp; (-x)); &#125; inline void Modify(int u, int v) &#123; while (u &lt;= cnt) &#123; T[u] += v; u += lowbit(u); &#125; &#125; inline int Query(int u) &#123; int ans = 0; while (u) &#123; ans += T[u]; u -= lowbit(u); &#125; return ans; &#125;&#125;BIT;int sqz()&#123; int n = read(), Size = sqrt(n); rep(i, 1, n) X[i].val = read(), X[i].id = i, Belong[i] = (i - 1) / Size + 1; sort(X + 1, X + n + 1, cmp1); rep(i, 1, n) &#123; if (X[i].val != X[i - 1].val) cnt++; Y[X[i].id] = cnt; &#125; int m = read(); rep(i, 1, m) Q[i].l = read(), Q[i].r = read(), Q[i].id = i; sort(Q + 1, Q + m + 1, cmp2); int L = 1, R = 0; rep(i, 1, m) &#123; while (L &lt; Q[i].l) BIT.Modify(Y[L], -1), ans -= BIT.Query(Y[L] - 1), L++; while (L &gt; Q[i].l) --L, BIT.Modify(Y[L], 1), ans += BIT.Query(Y[L] - 1); while (R &gt; Q[i].r) BIT.Modify(Y[R], -1), ans -= R - L - BIT.Query(Y[R]), R--; while (R &lt; Q[i].r) ++R, BIT.Modify(Y[R], 1), ans += R - L + 1 - BIT.Query(Y[R]); Ans[Q[i].id] = ans; &#125; rep(i, 1, m) printf(\"%lld\\n\", Ans[i]); return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"[BZOJ-2038]小Z的袜子","slug":"BZOJ-2038-小Z的袜子","date":"2018-06-21T14:01:08.000Z","updated":"2019-01-08T13:47:18.085Z","comments":true,"path":"2018/06/21/BZOJ-2038-小Z的袜子/","link":"","permalink":"http://yoursite.com/2018/06/21/BZOJ-2038-小Z的袜子/","excerpt":"Description 读入n个数，询问区间[L,R]之间取两个数相同的概率为多少。","text":"Description 读入n个数，询问区间[L,R]之间取两个数相同的概率为多少。 Solution 这是一道[国家集训队2009]的题。 使用莫队即可。 Notice 注意要开long long。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;struct node&#123; int l, r, id;&#125;Q[N + 5];int Belong[N + 5], X[N + 5], T[N + 5];ll Ansx[N + 5], Ansy[N + 5];ll ans = 0;int cmp(node X, node Y)&#123; return Belong[X.l] == Belong[Y.l] ? X.r &lt; Y.r : Belong[X.l] &lt; Belong[Y.l];&#125;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a % b) : a;&#125;void Insert(int pos)&#123; ans += T[X[pos]]; T[X[pos]]++;&#125;void Delete(int pos)&#123; T[X[pos]]--; ans -= T[X[pos]];&#125;int sqz()&#123; int n = read(), m = read(), Size = sqrt(n); rep(i, 1, n) X[i] = read(), Belong[i] = (i - 1) / Size + 1; rep(i, 1, m) Q[i].l = read(), Q[i].r = read(), Q[i].id = i; sort(Q + 1, Q + m + 1, cmp); int L = 1, R = 0; rep(i, 1, m) &#123; while (L &lt; Q[i].l) Delete(L++); while (L &gt; Q[i].l) Insert(--L); while (R &gt; Q[i].r) Delete(R--); while (R &lt; Q[i].r) Insert(++R); Ansx[Q[i].id] = ans, Ansy[Q[i].id] = (ll)(Q[i].r - Q[i].l + 1) * (Q[i].r - Q[i].l) / 2; &#125; rep(i, 1, m) &#123; ll g = gcd(Ansx[i], Ansy[i]); printf(\"%lld/%lld\\n\", Ansx[i] / g, Ansy[i] / g); &#125; return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"高级数据结构-莫队","slug":"高级数据结构-莫队","date":"2018-06-21T13:46:43.000Z","updated":"2018-07-25T08:29:00.693Z","comments":true,"path":"2018/06/21/高级数据结构-莫队/","link":"","permalink":"http://yoursite.com/2018/06/21/高级数据结构-莫队/","excerpt":"问题类型 适用于询问是一段区间[L,R]，可以离线，并且时间复杂度一个根号跑的过的情况下。","text":"问题类型 适用于询问是一段区间[L,R]，可以离线，并且时间复杂度一个根号跑的过的情况下。 解决方案 我们把n个数分成sqrt(n)个块，每个块就会有sqrt(n)个数。 假设i被分到了Belong[i]这个块。 我们先把所有询问按Belong[L]从小到大排序（如果Belong[L]相等，就按R从小到大）。 然后我们就把前一个区间暴力扩展删除到现在的区间为止。 L指针每一个询问最多移动sqrt(n)次，总共 q sqrt(n)。 R指针每不同的Belong[L]最多移动n次，最多sqrt(n)个块，总共 n sqrt(n)。 所以总时间复杂度为(n + q) * sqrt(n)。 代码演示1234567891011121314151617181920212223int cmp(node X, node Y)&#123; return Belong[X.l] == Belong[Y.l] ? X.r &lt; Y.r : Belong[X.l] &lt; Belong[Y.l];&#125;void Insert()void Delete()int main()&#123; Init(); sort(Q + 1, Q + m + 1, cmp); int L = 1, R = 0; rep(i, 1, m) &#123; while (L &lt; Q[i].l) Delete(L++); while (L &gt; Q[i].l) Insert(--L); while (R &gt; Q[i].r) Delete(R--); while (R &lt; Q[i].r) Insert(++R); Ans[Q[i].id] = Calc(); &#125;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"[BZOJ-1008]越狱","slug":"BZOJ-1008-越狱","date":"2018-06-20T13:36:10.000Z","updated":"2019-01-08T13:48:15.561Z","comments":true,"path":"2018/06/20/BZOJ-1008-越狱/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1008-越狱/","excerpt":"Description 给你n个空格，每个格子可以填1~m的数，问有多少种存在两个相邻数相等的方案。","text":"Description 给你n个空格，每个格子可以填1~m的数，问有多少种存在两个相邻数相等的方案。 Solution 这是一道[HNOI2008]的题。 我们发现求有两个相邻的数相等比较难求，于是我们使用容斥，用总方案数减去没有相邻数相等的方案数。 所以答案就是 m ^ n - m * (m - 1) ^ n. Notice 注意要开long long Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 100003;const int N = 2000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;ll pow(ll a, ll b, ll Mo)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % Mo; a = a * a % Mo; b &gt;&gt;= 1; &#125; return ans;&#125;int sqz()&#123; ll m = read(), n = read(); printf(\"%lld\\n\", (pow(m, n, Mo) - m * pow(m - 1, n - 1, Mo) % Mo + Mo) % Mo); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://yoursite.com/tags/容斥/"}]},{"title":"[BZOJ-1002]轮状病毒","slug":"BZOJ-1002-轮状病毒","date":"2018-06-20T11:12:04.000Z","updated":"2019-01-08T13:48:05.096Z","comments":true,"path":"2018/06/20/BZOJ-1002-轮状病毒/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1002-轮状病毒/","excerpt":"Description 如上图n轮状基由n个不同的基原子和圆心处的核原子构成。 n轮状病毒的产生就是n轮状基中删去若干条边，使得各原子间有唯一的信息通道。 求有多少个不同的n轮状病毒。","text":"Description 如上图n轮状基由n个不同的基原子和圆心处的核原子构成。 n轮状病毒的产生就是n轮状基中删去若干条边，使得各原子间有唯一的信息通道。 求有多少个不同的n轮状病毒。 Solution 这是一道[FJOI2007]的题。 打表找规律，我们发现F[i] = 3 * F[i - 1] - F[i - 2] + 2; Notice 我们发现可能会超出long long，所以我们要用到高精度。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 2000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;struct BigInteger&#123; int len, negative; int val[1005]; /* 转换 */ BigInteger(int x = 0) &#123; I_TO_B(x); &#125; BigInteger(char *st) &#123; C_TO_B(st); &#125; void C_TO_B(char *st) &#123; negative = 0; len = strlen(st); memset(val, 0, sizeof(val)); rep(i, 0, len - 1) val[i] = st[len - i - 1] - '0'; if (st[0] == '-') val[--len] = 0, negative = 1; while(len &gt; 0 &amp;&amp; val[len - 1] == 0) len--; &#125; void I_TO_B(int x) &#123; negative = 0; if (x &lt; 0) x = -x, negative = 1; len = 0; memset(val, 0, sizeof(val)); while(x) &#123; val[len++] = x % 10; x /= 10; &#125; &#125; /* 输入输出 */ friend istream &amp;operator &gt;&gt;(istream &amp;in, BigInteger &amp;t) &#123; char st[1005]; in &gt;&gt; st; t.C_TO_B(st); return in; &#125; friend ostream &amp;operator &lt;&lt;(ostream &amp;out, BigInteger &amp;t) &#123; if (t.negative) putchar('-'); per(i, t.len - 1, 0) out &lt;&lt; t.val[i]; return out; &#125; void print() &#123; if (negative) putchar('-'); per(i, len - 1, 0) putchar(val[i] + '0'); putchar('\\n'); &#125; /* 其他 */ friend void swap(BigInteger &amp;x, BigInteger &amp;y) &#123; BigInteger t = x; x = y; y = t; &#125; friend BigInteger operator -(BigInteger x) &#123; BigInteger t = x; t.negative = 1 - t.negative; return t; &#125; friend BigInteger abs(BigInteger x) &#123; BigInteger t = x; t.negative = 0; return t; &#125; /* 等于 or 不等于 */ friend bool operator ==(BigInteger x, BigInteger y) &#123; if (x.negative != y.negative) return 0; if (x.len != y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] != y.val[i]) return 0; return 1; &#125; friend bool operator ==(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x == y; &#125; friend bool operator ==(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x == y; &#125; friend bool operator !=(BigInteger x, BigInteger y) &#123; return !(x == y); &#125; friend bool operator !=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return !(x == y); &#125; friend bool operator !=(const int t, const BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return !(x == y); &#125; /* 小于 or 大于 */ friend bool operator &lt;(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; !y.negative) return 1; if (!x.negative &amp;&amp; y.negative) return 0; if (x.negative &amp;&amp; y.negative) swap(x, y); if (x.len &lt; y.len) return 1; if (x.len &gt; y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] &lt; y.val[i]) return 1; else if (x.val[i] &gt; y.val[i]) return 0; return 0; &#125; friend bool operator &lt;(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y; &#125; friend bool operator &lt;(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y; &#125; friend bool operator &gt;(BigInteger x, BigInteger y) &#123; return y &lt; x; &#125; friend bool operator &gt;(BigInteger x, int y) &#123; return y &lt; x; &#125; friend bool operator &gt;(int x, BigInteger y) &#123; return y &lt; x; &#125; /* 小于等于 or 大于等于 */ friend bool operator &lt;=(BigInteger x, BigInteger y) &#123; return x &lt; y || x == y; &#125; friend bool operator &lt;=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &lt;=(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &gt;=(BigInteger x, BigInteger y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(BigInteger x, int y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(int x, BigInteger y) &#123; return y &lt;= x; &#125; /* 加法 */ friend BigInteger operator +(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return -(abs(x) + abs(y)); if (x.negative &amp;&amp; !y.negative) return y - abs(x); if (!x.negative &amp;&amp; y.negative) return x - abs(y); int len = x.len &gt; y.len ? x.len : y.len; BigInteger ans; rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] + y.val[i]; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; if (ans.val[len] != 0) len++; ans.len = len; return ans; &#125; friend BigInteger operator +(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x + y; &#125; friend void operator +=(BigInteger &amp;x, BigInteger y) &#123; x = x + y; &#125; friend void operator +=(BigInteger &amp;x, int t) &#123; x = x + t; &#125; friend void operator ++(BigInteger &amp;x) &#123; x += 1; &#125; /* 减法 */ friend BigInteger operator -(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return abs(y) - abs(x); if (x.negative &amp;&amp; !y.negative) return -(abs(x) + y); if (!x.negative &amp;&amp; y.negative) return x + abs(y); BigInteger ans; if (x &lt; y) &#123; swap(x, y); ans.negative = 1; &#125; int len = max(x.len, y.len); rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] - y.val[i]; if (ans.val[i] &lt; 0) &#123; ans.val[i] += 10; ans.val[i + 1]--; &#125; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator -(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x - y; &#125; friend BigInteger operator -(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x - y; &#125; friend void operator -=(BigInteger &amp;x, BigInteger y) &#123; x = x - y; &#125; friend void operator -=(BigInteger &amp;x, int y) &#123; x = x - y; &#125; friend void operator --(BigInteger &amp;x) &#123; x -= 1; &#125; /* 乘法 */ friend BigInteger operator *(BigInteger x, BigInteger y) &#123; BigInteger ans; ans.negative = (x.negative ^ y.negative); int len = x.len + y.len; rep(i, 0, x.len - 1) rep(j, 0, y.len - 1) ans.val[i + j] += x.val[i] * y.val[j]; rep(i, 0, len - 1) &#123; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator *(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x * y; &#125; friend BigInteger operator *(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x * y; &#125; friend void operator *=(BigInteger &amp;x, BigInteger y) &#123; x = x * y; &#125; friend void operator *=(BigInteger &amp;x, int t) &#123; x = x * t; &#125; /* 除法 */ friend BigInteger operator /(BigInteger x, BigInteger y) &#123; BigInteger R, ans; if (y.len == 1 &amp;&amp; y.val[0] == 0) return R; per(i, x.len - 1, 0) &#123; ans *= 10; R = R * 10 + x.val[i]; while(R &gt;= y) &#123; ++ans; R -= y; &#125; &#125; return ans; &#125; friend BigInteger operator /(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x / y; &#125; friend BigInteger operator %(BigInteger x, BigInteger y) &#123; return x - x / y; &#125; friend BigInteger operator %(BigInteger x, int t) &#123; return x - x / t; &#125; friend void operator /=(BigInteger &amp;x, BigInteger y) &#123; x = x / y; &#125; friend void operator /=(BigInteger &amp;x, int t) &#123; x = x / t; &#125; friend void operator %=(BigInteger &amp;x, BigInteger y) &#123; x = x % y; &#125; friend void operator %=(BigInteger &amp;x, int t) &#123; x = x % t; &#125;&#125;Now, Pre1, Pre2;int sqz()&#123; Pre1 = 1, Pre2 = 0; int n = read(); if (n == 1) puts(\"1\"); else &#123; rep(i, 2, n) &#123; Now = Pre1 * 3 - Pre2 + 2; Pre2 = Pre1, Pre1 = Now; &#125; Now.print(); &#125; return 0;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/categories/高精度/"}],"tags":[{"name":"递推DP","slug":"递推DP","permalink":"http://yoursite.com/tags/递推DP/"},{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/tags/高精度/"}]},{"title":"高精度模版","slug":"高精度模版","date":"2018-06-20T11:07:09.000Z","updated":"2018-07-04T11:14:01.383Z","comments":true,"path":"2018/06/20/高精度模版/","link":"","permalink":"http://yoursite.com/2018/06/20/高精度模版/","excerpt":"问题类型 有时我们需要用到大于2^64的数的各种加减乘除运算，而C++中unsigned long long最多只支持2^64以内的数，这时我们就需要用到高精度了。","text":"问题类型 有时我们需要用到大于2^64的数的各种加减乘除运算，而C++中unsigned long long最多只支持2^64以内的数，这时我们就需要用到高精度了。 解决方案 我们用一个数组来模拟一个数的各个数位，来进行各种运算。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350struct BigInteger&#123; int len, negative; int val[1005]; /* 转换 */ BigInteger(int x = 0) &#123; I_TO_B(x); &#125; BigInteger(char *st) &#123; C_TO_B(st); &#125; void C_TO_B(char *st) &#123; negative = 0; len = strlen(st); memset(val, 0, sizeof(val)); rep(i, 0, len - 1) val[i] = st[len - i - 1] - '0'; if (st[0] == '-') val[--len] = 0, negative = 1; while(len &gt; 0 &amp;&amp; val[len - 1] == 0) len--; &#125; void I_TO_B(int x) &#123; negative = 0; if (x &lt; 0) x = -x, negative = 1; len = 0; memset(val, 0, sizeof(val)); while(x) &#123; val[len++] = x % 10; x /= 10; &#125; &#125; /* 输入输出 */ friend istream &amp;operator &gt;&gt;(istream &amp;in, BigInteger &amp;t) &#123; char st[1005]; in &gt;&gt; st; t.C_TO_B(st); return in; &#125; friend ostream &amp;operator &lt;&lt;(ostream &amp;out, BigInteger &amp;t) &#123; if (t.negative) putchar('-'); per(i, t.len - 1, 0) out &lt;&lt; t.val[i]; return out; &#125; void print() &#123; if (negative) putchar('-'); per(i, len - 1, 0) putchar(val[i] + '0'); putchar('\\n'); &#125; /* 其他 */ friend void swap(BigInteger &amp;x, BigInteger &amp;y) &#123; BigInteger t = x; x = y; y = t; &#125; friend BigInteger operator -(BigInteger x) &#123; BigInteger t = x; t.negative = 1 - t.negative; return t; &#125; friend BigInteger abs(BigInteger x) &#123; BigInteger t = x; t.negative = 0; return t; &#125; /* 等于 or 不等于 */ friend bool operator ==(BigInteger x, BigInteger y) &#123; if (x.negative != y.negative) return 0; if (x.len != y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] != y.val[i]) return 0; return 1; &#125; friend bool operator ==(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x == y; &#125; friend bool operator ==(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x == y; &#125; friend bool operator !=(BigInteger x, BigInteger y) &#123; return !(x == y); &#125; friend bool operator !=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return !(x == y); &#125; friend bool operator !=(const int t, const BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return !(x == y); &#125; /* 小于 or 大于 */ friend bool operator &lt;(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; !y.negative) return 1; if (!x.negative &amp;&amp; y.negative) return 0; if (x.negative &amp;&amp; y.negative) swap(x, y); if (x.len &lt; y.len) return 1; if (x.len &gt; y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] &lt; y.val[i]) return 1; else if (x.val[i] &gt; y.val[i]) return 0; return 0; &#125; friend bool operator &lt;(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y; &#125; friend bool operator &lt;(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y; &#125; friend bool operator &gt;(BigInteger x, BigInteger y) &#123; return y &lt; x; &#125; friend bool operator &gt;(BigInteger x, int y) &#123; return y &lt; x; &#125; friend bool operator &gt;(int x, BigInteger y) &#123; return y &lt; x; &#125; /* 小于等于 or 大于等于 */ friend bool operator &lt;=(BigInteger x, BigInteger y) &#123; return x &lt; y || x == y; &#125; friend bool operator &lt;=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &lt;=(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &gt;=(BigInteger x, BigInteger y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(BigInteger x, int y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(int x, BigInteger y) &#123; return y &lt;= x; &#125; /* 加法 */ friend BigInteger operator +(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return -(abs(x) + abs(y)); if (x.negative &amp;&amp; !y.negative) return y - abs(x); if (!x.negative &amp;&amp; y.negative) return x - abs(y); int len = x.len &gt; y.len ? x.len : y.len; BigInteger ans; rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] + y.val[i]; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; if (ans.val[len] != 0) len++; ans.len = len; return ans; &#125; friend BigInteger operator +(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x + y; &#125; friend void operator +=(BigInteger &amp;x, BigInteger y) &#123; x = x + y; &#125; friend void operator +=(BigInteger &amp;x, int t) &#123; x = x + t; &#125; friend void operator ++(BigInteger &amp;x) &#123; x += 1; &#125; /* 减法 */ friend BigInteger operator -(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return abs(y) - abs(x); if (x.negative &amp;&amp; !y.negative) return -(abs(x) + y); if (!x.negative &amp;&amp; y.negative) return x + abs(y); BigInteger ans; if (x &lt; y) &#123; swap(x, y); ans.negative = 1; &#125; int len = max(x.len, y.len); rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] - y.val[i]; if (ans.val[i] &lt; 0) &#123; ans.val[i] += 10; ans.val[i + 1]--; &#125; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator -(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x - y; &#125; friend BigInteger operator -(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x - y; &#125; friend void operator -=(BigInteger &amp;x, BigInteger y) &#123; x = x - y; &#125; friend void operator -=(BigInteger &amp;x, int y) &#123; x = x - y; &#125; friend void operator --(BigInteger &amp;x) &#123; x -= 1; &#125; /* 乘法 */ friend BigInteger operator *(BigInteger x, BigInteger y) &#123; BigInteger ans; ans.negative = (x.negative ^ y.negative); int len = x.len + y.len; rep(i, 0, x.len - 1) rep(j, 0, y.len - 1) ans.val[i + j] += x.val[i] * y.val[j]; rep(i, 0, len - 1) &#123; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator *(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x * y; &#125; friend BigInteger operator *(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x * y; &#125; friend void operator *=(BigInteger &amp;x, BigInteger y) &#123; x = x * y; &#125; friend void operator *=(BigInteger &amp;x, int t) &#123; x = x * t; &#125; /* 除法 */ friend BigInteger operator /(BigInteger x, BigInteger y) &#123; BigInteger R, ans; if (y.len == 1 &amp;&amp; y.val[0] == 0) return R; per(i, x.len - 1, 0) &#123; ans *= 10; R = R * 10 + x.val[i]; while(R &gt;= y) &#123; ++ans; R -= y; &#125; &#125; return ans; &#125; friend BigInteger operator /(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x / y; &#125; friend BigInteger operator %(BigInteger x, BigInteger y) &#123; return x - x / y; &#125; friend BigInteger operator %(BigInteger x, int t) &#123; return x - x / t; &#125; friend void operator /=(BigInteger &amp;x, BigInteger y) &#123; x = x / y; &#125; friend void operator /=(BigInteger &amp;x, int t) &#123; x = x / t; &#125; friend void operator %=(BigInteger &amp;x, BigInteger y) &#123; x = x % y; &#125; friend void operator %=(BigInteger &amp;x, int t) &#123; x = x % t; &#125;&#125;;","categories":[{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/categories/高精度/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/tags/高精度/"}]},{"title":"[BZOJ-1968]约束研究","slug":"BZOJ-1968-约束研究","date":"2018-06-20T11:04:34.000Z","updated":"2019-01-08T13:49:38.196Z","comments":true,"path":"2018/06/20/BZOJ-1968-约束研究/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1968-约束研究/","excerpt":"Description 求出1～n的约数个数和。","text":"Description 求出1～n的约数个数和。 Solution 这是一道[AHOI2005]的题。 我们考虑每个约数出现了多少次，枚举约数即可。 Notice 没什么要注意的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 2000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int sqz()&#123; int n = read(), ans = 0; rep(i, 1, n) ans += n / i; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-1192]鬼谷子的钱袋","slug":"BZOJ-1192-鬼谷子的钱袋","date":"2018-06-20T10:29:18.000Z","updated":"2019-01-08T13:48:54.470Z","comments":true,"path":"2018/06/20/BZOJ-1192-鬼谷子的钱袋/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1192-鬼谷子的钱袋/","excerpt":"Description 读入一个数n，你要求你至少把n拆分成几个数是的随意组合后能表示1～n的任意一个数。","text":"Description 读入一个数n，你要求你至少把n拆分成几个数是的随意组合后能表示1～n的任意一个数。 Solution 这是一道[HNOI2006]的题。 找到第一个大于n的2^k数，输出k。 Notice 注意是大于n的2^k数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 1000000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int sqz()&#123; int n = read(); int now = 1, cnt = 0; while (n &gt; now) n -= now, cnt++, now *= 2; printf(\"%d\\n\", cnt + 1);&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-1864]三色二叉树","slug":"BZOJ-1864-三色二叉树","date":"2018-05-30T11:11:40.000Z","updated":"2019-01-08T13:49:15.306Z","comments":true,"path":"2018/05/30/BZOJ-1864-三色二叉树/","link":"","permalink":"http://yoursite.com/2018/05/30/BZOJ-1864-三色二叉树/","excerpt":"Description 一棵二叉树用一个由0,1,2的字符串表示。 如当前节点是叶子节点，则为0，若有一个儿子v则为1v。 若有两个儿子v1,v2则为2v1v2。 我们给每个节点染色（有3种颜色：红绿蓝），要求每个点的颜色与父亲和兄弟都不相同。 问最多和最少可以有多少个绿色节点。","text":"Description 一棵二叉树用一个由0,1,2的字符串表示。 如当前节点是叶子节点，则为0，若有一个儿子v则为1v。 若有两个儿子v1,v2则为2v1v2。 我们给每个节点染色（有3种颜色：红绿蓝），要求每个点的颜色与父亲和兄弟都不相同。 问最多和最少可以有多少个绿色节点。 Solution 这是一道[ZJOI2006]的题。 用树形DP即可。以求最大值为例： 我们用F[u][0]表示i不为绿色时子树中绿色节点数量的最大值。 我们用F[u][0]表示i为绿色时子树中绿色节点数量的最大值。 F[u][0] = Max(F[v1][1] + F[v2][0], F[v1][0] + F[v2][1]) F[u][1] = F[v1][0] + F[v2][0] 求最小值时同理。 Notice 建树时有些细节。 #Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 51061;const int N = 100000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n = 0;int L[N + 5], R[N + 5], F[N + 5][2], G[N + 5][2];void dfs()&#123; int point = ++n; char ch = getchar(); if (ch == '0') return; if (ch == '1') &#123; L[point] = n + 1; dfs(); &#125; else &#123; L[point] = n + 1; dfs(); R[point] = n + 1; dfs(); &#125;&#125;void DP(int u)&#123; if (!u) return; DP(L[u]), DP(R[u]); F[u][1] = F[L[u]][0] + F[R[u]][0] + 1; F[u][0] = max(F[L[u]][1] + F[R[u]][0], F[L[u]][0] + F[R[u]][1]); G[u][1] = G[L[u]][0] + G[R[u]][0] + 1; G[u][0] = min(G[L[u]][1] + G[R[u]][0], G[L[u]][0] + G[R[u]][1]);&#125;int sqz()&#123; dfs(); DP(1); printf(\"%d %d\\n\", max(F[1][1], F[1][0]), min(G[1][1], G[1][0])); return 0;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"}]},{"title":"[BZOJ-2631]tree","slug":"BZOJ-2631-tree","date":"2018-05-29T01:42:27.000Z","updated":"2019-01-08T13:50:43.409Z","comments":true,"path":"2018/05/29/BZOJ-2631-tree/","link":"","permalink":"http://yoursite.com/2018/05/29/BZOJ-2631-tree/","excerpt":"Description 一棵n个点的树，每个点的初始权值为1。对于这棵树有q个操作，每个操作为以下四种操作之一： “+ u v c”：将u到v的路径上的点的权值都加上自然数c； “- u1 v1 u2 v2”：将树中原有的边(u1,v1)删除，加入一条新边(u2,v2)，保证操作完之后仍然是一棵树； “* u v c”：将u到v的路径上的点的权值都乘上自然数c； “/ u v”：询问u到v的路径上的点的权值和，求出答案对于51061的余数。","text":"Description 一棵n个点的树，每个点的初始权值为1。对于这棵树有q个操作，每个操作为以下四种操作之一： “+ u v c”：将u到v的路径上的点的权值都加上自然数c； “- u1 v1 u2 v2”：将树中原有的边(u1,v1)删除，加入一条新边(u2,v2)，保证操作完之后仍然是一棵树； “* u v c”：将u到v的路径上的点的权值都乘上自然数c； “/ u v”：询问u到v的路径上的点的权值和，求出答案对于51061的余数。 Solution LCT的模板题 Notice 注意Link和Cut的时候不用判是否联通，否则会TLE。 还有要用unsigned int，int会爆，longlong会被卡常。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 51061;const int N = 100000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;char st[5];struct LinkCutTree&#123; int Fa[N + 5], Son[N + 5][2], rev[N + 5], Size[N + 5], Stack[N + 5], top; unsigned Sum[N + 5], Val[N + 5], Mul[N + 5], Add[N + 5]; inline void Modify(int u, int a, int m) &#123; if (!u) return; Sum[u] = (Sum[u] * m + Size[u] * a) % Mo; Val[u] = (Val[u] * m + a) % Mo; Mul[u] = (Mul[u] * m) % Mo; Add[u] = (Add[u] * m + a) % Mo; &#125; inline void up(int u) &#123; Size[u] = (Size[Son[u][0]] + Size[Son[u][1]] + 1) % Mo; Sum[u] = (Sum[Son[u][0]] + Sum[Son[u][1]] + Val[u]) % Mo; &#125; inline void down(int u) &#123; if (rev[u]) &#123; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; if (Add[u] != 0 || Mul[u] != 1) &#123; Modify(Son[u][0], Add[u], Mul[u]); Modify(Son[u][1], Add[u], Mul[u]); &#125; Add[u] = 0, Mul[u] = 1; &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y), up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[z][1] == y) ^ (Son[y][1] == x)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); Access(y); Splay(y); Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(), m = read(); rep(i, 1, n) LCT.Val[i] = LCT.Mul[i] = 1; Rep(i, 1, n) LCT.Link((int)read(), (int)read()); while (m--) &#123; scanf(\"%s\", st); if (st[0] == '+') &#123; int x = read(), y = read(), z = read(); LCT.Split(x, y), LCT.Modify(y, z, 1); &#125; if (st[0] == '-') &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(); LCT.Cut(x1, y1), LCT.Link(x2, y2); &#125; if (st[0] == '*') &#123; int x = read(), y = read(), z = read(); LCT.Split(x, y), LCT.Modify(y, 0, z); &#125; if (st[0] == '/') &#123; int x = read(), y = read(); LCT.Split(x, y); printf(\"%u\\n\", LCT.Sum[y]); &#125; &#125; return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-3669]魔法森林","slug":"BZOJ-3669-魔法森林","date":"2018-05-20T06:28:25.000Z","updated":"2019-01-08T13:51:12.922Z","comments":true,"path":"2018/05/20/BZOJ-3669-魔法森林/","link":"","permalink":"http://yoursite.com/2018/05/20/BZOJ-3669-魔法森林/","excerpt":"Description 给你一张n个点m条边的无向图，每条边有两个属性a和b。 你需要找到一条从1～n的路径，使得这些边的第一个属性最大值加上第二个属性最大值的值最小。","text":"Description 给你一张n个点m条边的无向图，每条边有两个属性a和b。 你需要找到一条从1～n的路径，使得这些边的第一个属性最大值加上第二个属性最大值的值最小。 Solution 这是一道[NOI2014]的题。 我们先把边按a的值从小到大排序，然后我们依次扫过每一条边。 这样我们当前边的a属性最大值是可以确定的，我们就要让b属性的最大值尽量小。 我们每扫描一条边，如果这条边的两端u,v已经相连了，那我们找到u到v的路径上b属性最大的边e。 如果e的b比当前的b要大，那么就割掉e与两端端点之间的连边，连接当前边与u,v的连边。 这样就保证了不会有环出现。 如果这条边两端u,v不相连，直接与u,v相连即可。 我们可以用LCT维护这个东西，把边权转化为点权。 Notice 我们用LCT维护b属性最大的边的序号可以更方便，而不是维护最大的b属性值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000, M = 100000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;struct node&#123; int u, v, a, b; node() &#123;&#125; node(int _u, int _v, int _a, int _b) &#123;u = _u, v = _v, a = _a, b = _b;&#125;&#125;Edge[M + 5];inline int cmp(node X, node Y)&#123; return X.a &lt; Y.a;&#125;struct LinkCutTree&#123; int Val[N + M + 5], Fa[N + M + 5], Son[N + M + 5][2], rev[N + M + 5], Max[N + M + 5], Stack[N + M + 5], top; inline void up(int u) &#123; Max[u] = u; if (Son[u][0] &amp;&amp; Val[Max[Son[u][0]]] &gt; Val[Max[u]]) Max[u] = Max[Son[u][0]]; if (Son[u][1] &amp;&amp; Val[Max[Son[u][1]]] &gt; Val[Max[u]]) Max[u] = Max[Son[u][1]]; &#125; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y); up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[z][1] == y) ^ (Son[y][1] == x)) Rotate(x); Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(), m = read(), cnt = 0, ans = INF; rep(i, 1, m) &#123; int u = read(), v = read(), a = read(), b = read(); if (u == v) continue; Edge[++cnt] = node(u, v, a, b); &#125; sort(Edge + 1, Edge + cnt + 1, cmp); rep(i, 1, cnt) &#123; LCT.Val[n + i] = Edge[i].b; if (LCT.Find_Root(Edge[i].u) == LCT.Find_Root(Edge[i].v)) &#123; LCT.Split(Edge[i].u, Edge[i].v); int x = LCT.Max[Edge[i].v] - n; if (LCT.Val[x + n] &gt; Edge[i].b) &#123; LCT.Cut(x + n, Edge[x].u), LCT.Cut(x + n, Edge[x].v); LCT.Link(i + n, Edge[i].u), LCT.Link(i + n, Edge[i].v); &#125; &#125; else LCT.Link(i + n, Edge[i].u), LCT.Link(i + n, Edge[i].v); if (LCT.Find_Root(1) == LCT.Find_Root(n)) ans = min(ans, Edge[i].a + (LCT.Split(1, n), LCT.Val[LCT.Max[n]])); &#125; printf(\"%d\\n\", ans == INF ? -1 : ans); return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-2049]洞穴勘测","slug":"BZOJ-2049-洞穴勘测","date":"2018-05-17T10:44:48.000Z","updated":"2019-01-08T13:49:54.972Z","comments":true,"path":"2018/05/17/BZOJ-2049-洞穴勘测/","link":"","permalink":"http://yoursite.com/2018/05/17/BZOJ-2049-洞穴勘测/","excerpt":"Description 有3种操作: 连接两个点，隔断两个点，问两个点是否联通。","text":"Description 有3种操作: 连接两个点，隔断两个点，问两个点是否联通。 Solution 这是一道[SDOI2008]的题。 LCT的裸题。 Notice 询问操作只要判断两个点的Find_Root即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 10000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;char st[15];struct LinkCutTree&#123; int Fa[N + 5], Son[N + 5][2], rev[N + 5], Stack[N + 5], top; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[z][1] == y) ^ (Son[y][1] == x)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last; &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(), q = read(); while (q--) &#123; scanf(\"%s\", st); int x = read(), y = read(); if (st[0] == 'Q') &#123; if (LCT.Find_Root(x) == LCT.Find_Root(y)) puts(\"Yes\"); else puts(\"No\"); &#125; if (st[0] == 'C') LCT.Link(x, y); if (st[0] == 'D') LCT.Cut(x, y); &#125;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-2002]弹飞绵羊","slug":"BZOJ-2002-弹飞绵羊","date":"2018-05-17T07:34:16.000Z","updated":"2019-01-08T13:49:45.195Z","comments":true,"path":"2018/05/17/BZOJ-2002-弹飞绵羊/","link":"","permalink":"http://yoursite.com/2018/05/17/BZOJ-2002-弹飞绵羊/","excerpt":"Description 有n个装置，在第i个装置上会被弹到第i+X[i]个装置上，弹到大于n的装置即视为弹飞。 询问操作询问在一个装置弹几次会被弹飞，修改操作会修改X值。","text":"Description 有n个装置，在第i个装置上会被弹到第i+X[i]个装置上，弹到大于n的装置即视为弹飞。 询问操作询问在一个装置弹几次会被弹飞，修改操作会修改X值。 Solution 这是一道[HNOI2010]的题。 每次i和i+X[i]连边，从一个点走多少步走到n+1节点即为答案。 每次修改时先删边再加边即可。 Notice 注意原题中编号是0～n-1的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 300000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int X[N + 5];struct LinkCutTree&#123; int Fa[N + 5], rev[N + 5], Son[N + 5][2], Size[N + 5], Stack[N + 5], top; inline void up(int u) &#123; Size[u] = Size[Son[u][0]] + Size[Son[u][1]] + 1; &#125; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y); up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[y][1] == x) ^ (Son[z][1] == y)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u); Splay(u); rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(); rep(i, 1, n) X[i] = read(); rep(i, 1, n) LCT.Link(i, i + X[i] &lt;= n ? i + X[i] : n + 1); int q = read(); while (q--) &#123; int op = read(); if (op == 1) &#123; int x = read() + 1; LCT.Split(x, n + 1); printf(\"%d\\n\", LCT.Size[n + 1] - 1); &#125; else &#123; int x = read() + 1, y = read(); LCT.Cut(x, x + X[x] &lt;= n ? x + X[x] : n + 1); LCT.Link(x, x + y &lt;= n ? x + y : n + 1); X[x] = y; &#125; &#125;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"高级数据结构-LCT","slug":"高级数据结构-LCT","date":"2018-05-16T04:30:42.000Z","updated":"2018-07-26T12:22:25.724Z","comments":true,"path":"2018/05/16/高级数据结构-LCT/","link":"","permalink":"http://yoursite.com/2018/05/16/高级数据结构-LCT/","excerpt":"问题类型 有时我们需要用一种数据结构去维护树形结构，并且支持删边加边操作。 这时我们就需要用到LCT了。","text":"问题类型 有时我们需要用一种数据结构去维护树形结构，并且支持删边加边操作。 这时我们就需要用到LCT了。 解决方案 LCT全称是Link_Cut_Tree，也叫做动态树。 LCT其实和轻重链剖分有些相似，我们给原树中的每个节点设置一个重儿子，到偏好儿子的边称为偏好边，一段连续的偏好边称为偏好链。 我们用每个splay去维护每个偏好链，在splay中以节点的深度做为关键字。 然后splay的根向splay深度最浅点在原树中的父亲连一条虚边。 LCT的基本操作： Access(u): 把u到原树的根的路径上所有边都变成偏好边，并且把u的偏好儿子设为空。 Make_Root(u): 把u变成原树的根。 Find_Root(u): 找出u所在的树的根。 Link(u, v): 连接u,v这条边 Cut(u, v): 割除u, v这条边 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct LinkCutTree&#123; int rev[N + 5], val[N + 5], Son[N + 5][2], Fa[N + 5], Stack[N + 5], top; inline void up(int u) &#123; val[u] = val[Son[u][0]] ^ val[Son[u][1]] ^ X[u]; &#125; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y), up(x); &#125; void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[y][1] == x) ^ (Son[z][1] == y)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-3572]世界树","slug":"BZOJ-3572-世界树","date":"2018-05-15T00:14:43.000Z","updated":"2019-01-08T13:51:05.171Z","comments":true,"path":"2018/05/15/BZOJ-3572-世界树/","link":"","permalink":"http://yoursite.com/2018/05/15/BZOJ-3572-世界树/","excerpt":"Description 给你一棵n个点的树，m次询问。 每次询问给出一些关键点，树上所有的点被距离它最近的关键点管辖，求每个关键点管辖多少点。 n ≤ 300000, m ≤ 300000, Sigma(关键点个数) &lt;= 300000","text":"Description 给你一棵n个点的树，m次询问。 每次询问给出一些关键点，树上所有的点被距离它最近的关键点管辖，求每个关键点管辖多少点。 n ≤ 300000, m ≤ 300000, Sigma(关键点个数) &lt;= 300000 Solution 这是一道[HNOI2014]的题。 我们可以用上下DP求出每个点被哪些点管辖，时间复杂度是 O(nm)的。 我们考虑建出虚树，建完虚树后用上下DP处理出虚树上每个点被哪些关键点管辖。 然后我们考虑一个关键点可以管辖哪些点。 对于深度比它大的点，一定是它的子树去掉某些子树。对于深度比它小的点，一定是它的某个祖先的子树去掉它。 我们考虑枚举虚树上的每一条边：如果它两端点不被同一个关键点管辖，则倍增找出一个分界点，然后处理答案即可。 Notice 此题细节较多，处理很麻烦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 300000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n, m, edgenum = 0, num, idx;int head[N + 5], Belong[N + 5], Size[N + 5], Rest[N + 5], Ans[N + 5], Dis[N + 5], Deep[N + 5], Fa[N + 5][20], X[N + 5], Y[N + 5], Z[N + 5], dfn[N + 5], stack[N + 5];struct node&#123; int vet, next;&#125;edge[2 * N + 5];void addedge(int u, int v)&#123; edge[edgenum].vet = v; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y];&#125;void dfs(int u, int fa)&#123; Size[u] = 1, Deep[u] = Deep[fa] + 1, dfn[u] = ++idx, Fa[u][0] = fa; rep(i, 1, 19) Fa[u][i] = Fa[Fa[u][i - 1]][i - 1]; travel(i, u) &#123; int v = edge[i].vet; if (v == fa) continue; dfs(v, u); Size[u] += Size[v]; &#125;&#125;int lca(int x, int y)&#123; if (Deep[x] &lt; Deep[y]) swap(x, y); per(i, 19, 0) if (Deep[Fa[x][i]] &gt;= Deep[y]) x = Fa[x][i]; if (x == y) return x; per(i, 19, 0) if (Fa[x][i] != Fa[y][i]) x = Fa[x][i], y = Fa[y][i]; return Fa[x][0];&#125;void Build()&#123; sort(X + 1, X + m + 1, cmp); int top = 0; stack[++top] = 1; rep(i, 1, m) &#123; if (X[i] == 1) continue; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; addedge(Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1], stack[top]); top--; &#125; if (!top || stack[top] != u) stack[++top] = u; stack[++top] = X[i]; &#125; while (--top) addedge(stack[top], stack[top + 1]);&#125;void up_dfs(int u)&#123; Z[++num] = u; Rest[u] = Size[u]; travel(i, u) &#123; int v = edge[i].vet; up_dfs(v); if (!Belong[v]) continue; int dis1 = Deep[Belong[v]] - Deep[u], dis2 = Belong[u] ? Deep[Belong[u]] - Deep[u] : INF; if (dis1 &lt; dis2 || dis1 == dis2 &amp;&amp; Belong[v] &lt; Belong[u]) Belong[u] = Belong[v]; &#125; Dis[u] = Deep[Belong[u]] - Deep[u];&#125;void down_dfs(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; int dis1 = Dis[u] + Deep[v] - Deep[u], dis2 = Dis[v]; if (dis1 &lt; dis2 || dis1 == dis2 &amp;&amp; Belong[u] &lt; Belong[v]) Belong[v] = Belong[u], Dis[v] = dis1; down_dfs(v); &#125;&#125;void Solve(int u, int v)&#123; int mid = v; if (Belong[u] == Belong[v]) &#123; Rest[u] -= Size[v]; return; &#125; per(i, 19, 0) &#123; int x = Fa[mid][i]; if (Deep[x] &lt;= Deep[u]) continue; int dis1 = Dis[u] + Deep[x] - Deep[u], dis2 = Dis[v] + Deep[v] - Deep[x]; if (dis1 &gt; dis2 || dis1 == dis2 &amp;&amp; Belong[u] &gt; Belong[v]) mid = x; &#125; Rest[u] -= Size[mid]; Ans[Belong[v]] += Size[mid] - Size[v];&#125;int sqz()&#123; n = read(); rep(i, 1, n) head[i] = -1; Rep(i, 1, n) &#123; int u = read(), v = read(); addedge(u, v), addedge(v, u); &#125; dfs(1, 0); edgenum = 0; rep(i, 1, n) head[i] = -1; int q = read(); while (q--) &#123; m = read(); num = idx = 0; rep(i, 1, m) X[i] = Y[i] = read(), Belong[X[i]] = X[i]; Build(); up_dfs(1); down_dfs(1); rep(i, 1, num) travel(j, Z[i]) Solve(Z[i], edge[j].vet); rep(i, 1, num) Ans[Belong[Z[i]]] += Rest[Z[i]]; rep(i, 1, m) printf(\"%d%c\", Ans[Y[i]], i == m ? '\\n' : ' '); rep(i, 1, num) head[Z[i]] = -1, Belong[Z[i]] = Ans[Z[i]] = Rest[Z[i]] = 0; &#125;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"},{"name":"上下DP","slug":"上下DP","permalink":"http://yoursite.com/tags/上下DP/"}]},{"title":"[BZOJ-2286]消耗战","slug":"BZOJ-2286-消耗战","date":"2018-05-12T01:08:49.000Z","updated":"2019-01-08T13:50:06.068Z","comments":true,"path":"2018/05/12/BZOJ-2286-消耗战/","link":"","permalink":"http://yoursite.com/2018/05/12/BZOJ-2286-消耗战/","excerpt":"Description 给你一棵n个点的树，每条边上有边权。 有m次询问，每次询问都给出一些关键点。你要割掉一些边，使得从1出发无法到达这些关键点。 求割掉边的边权总和最小值。 n ≤ 250000, m ≥ 1, Sigma(关键点个数) ≤ 500000","text":"Description 给你一棵n个点的树，每条边上有边权。 有m次询问，每次询问都给出一些关键点。你要割掉一些边，使得从1出发无法到达这些关键点。 求割掉边的边权总和最小值。 n ≤ 250000, m ≥ 1, Sigma(关键点个数) ≤ 500000 Solution 这是一道[SDOI2011]的题。 首先我们考虑树形DP，F[u]表示从u出发到不了u的子树中所有关键点的最小代价。 那么如果u的儿子v是关键点，那么F[u] += Dis(u, v)——(u, v)这条边一定得割 否则F[u] += min(F[v], Dis(u, v)) 这样我们得到了一个O(n)的DP，但询问m次后时间复杂度就很大了。 所以我们需要用虚树处理，这样总时间复杂度就是O(关键点个数)了。 Notice 因为这道题是树形DP，只要从下向上转移即可，所以不用把虚树边练出来，只要记录每个关键点及LCA在虚树中的父亲即可。 还要倍增预处理祖先和到祖先边权的最小值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 250000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n, num, tmp, edgenum = 0, Time = 0, top;int head[N + 5], X[N + 5], Y[N + 5], dfn[N + 5], Deep[N + 5], fa[N + 5], Fa[N + 5][20], Dis[N + 5][20], stack[N + 5], flag[N + 5];ll Ans[N + 5];struct node&#123; int vet, val, next;&#125;edge[2 * N + 5];void addedge(int u, int v, int w)&#123; edge[edgenum].vet = v; edge[edgenum].val = w; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;void dfs(int u, int fa)&#123; dfn[u] = ++Time; Deep[u] = Deep[fa] + 1; travel(i, u) &#123; int v = edge[i].vet; if (v == fa) continue; Fa[v][0] = u, Dis[v][0] = edge[i].val; dfs(v, u); &#125;&#125;void Prepare()&#123; rep(i, 1, 18) rep(j, 1, n) &#123; Fa[j][i] = Fa[Fa[j][i - 1]][i - 1]; Dis[j][i] = min(Dis[j][i - 1], Dis[Fa[j][i - 1]][i - 1]); &#125;&#125;int lca(int u, int v)&#123; if (Deep[u] &lt; Deep[v]) swap(u, v); per(i, 18, 0) if (Deep[Fa[u][i]] &gt;= Deep[v]) u = Fa[u][i]; if (u == v) return u; per(i, 18, 0) if (Fa[u][i] != Fa[v][i]) u = Fa[u][i], v = Fa[v][i]; return Fa[u][0];&#125;int dis(int u, int v)&#123; int ans = INF; if (Deep[u] &lt; Deep[v]) swap(u, v); per(i, 18, 0) if (Deep[Fa[u][i]] &gt;= Deep[v]) ans = min(ans, Dis[u][i]), u = Fa[u][i]; return ans;&#125;int cmp(int x, int y)&#123; return dfn[x] &lt; dfn[y];&#125;void Build()&#123; sort(X + 1, X + num + 1, cmp); stack[top = 1] = X[1]; rep(i, 2, num) &#123; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; fa[stack[top]] = Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1]; top--; &#125; if (!top || u != stack[top]) &#123; X[++tmp] = u; stack[++top] = u; &#125; stack[++top] = X[i]; &#125; while (--top) fa[stack[top + 1]] = stack[top];&#125;ll solve()&#123; sort(X + 1, X + tmp + 1, cmp); rep(i, 1, tmp) Ans[X[i]] = 0; per(i, tmp, 2) &#123; if (flag[X[i]]) Ans[fa[X[i]]] += (ll)dis(X[i], fa[X[i]]); else Ans[fa[X[i]]] += min((ll)dis(X[i], fa[X[i]]), Ans[X[i]]); &#125; return Ans[1];&#125;int sqz()&#123; n = read(); rep(i, 1, n) head[i] = -1; Rep(i, 1, n) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w), addedge(v, u, w); &#125; dfs(1, 0); Prepare(); int m = read(); while (m--) &#123; tmp = num = read() + 1, X[1] = 1; rep(i, 2, num) X[i] = Y[i] = read(), flag[X[i]] = 1; Build(); printf(\"%lld\\n\", solve()); rep(i, 2, num) flag[Y[i]] = 0; &#125;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"},{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"}]},{"title":"高级数据结构-虚树","slug":"高级数据结构-虚树","date":"2018-05-11T16:00:00.000Z","updated":"2019-01-04T03:15:24.921Z","comments":true,"path":"2018/05/12/高级数据结构-虚树/","link":"","permalink":"http://yoursite.com/2018/05/12/高级数据结构-虚树/","excerpt":"问题类型 有些问题一次询问需要O(n)的复杂度，但多次询问时间复杂度会很大。 但如果我们只需要用到题目中给出的一些关键点和它们的LCA，并且给出的关键点个数总和并不多，我们可以求出它们的LCA，建成虚树，一次询问就变成了O(关键点个数)","text":"问题类型 有些问题一次询问需要O(n)的复杂度，但多次询问时间复杂度会很大。 但如果我们只需要用到题目中给出的一些关键点和它们的LCA，并且给出的关键点个数总和并不多，我们可以求出它们的LCA，建成虚树，一次询问就变成了O(关键点个数) 解决方案 从上文得知，我们需要找出关键点的LCA并且建成虚树。 这时我们就需要用到栈。（在后文我们简称关键点的LCA为重要点） 我们用栈维护从根到当前关键点的路径上的重要点。 我们先把关键点按DFS序从小到大排序。 然后每次新枚举一个关键点u，求出它与栈顶v（上一个关键点）的LCA:w。 如果u是v的子孙，那么w=v，直接把u加入栈即可。 如果u不是v的子孙，那么w的深度一定比v要浅，所以我们就一直弹栈顶，知道栈顶的深度≤w的深度。 这时如果栈顶不是w，再把w加入栈。最后再把当前关键点加入栈。 我们在每次弹栈的时候，就把栈顶和相邻元素连边。（注意最后还要把栈弹空） 代码演示1234567891011121314151617void Build()&#123; sort(X + 1, X + num + 1, cmp); stack[top = 1] = X[1]; rep(i, 2, num) &#123; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; addedge(stack[top], Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1]); top--; &#125; if (!top || u != stack[top]) stack[++top] = u; stack[++top] = X[i]; &#125; while (--top) addedge(stack[top + 1]], stack[top]);&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-05-11T11:21:10.000Z","updated":"2018-07-04T11:15:07.614Z","comments":true,"path":"2018/05/11/Hello-World/","link":"","permalink":"http://yoursite.com/2018/05/11/Hello-World/","excerpt":"Wizard Cowboy终于有自己的博客啦 搞了半天终于基本成型了。。。","text":"Wizard Cowboy终于有自己的博客啦 搞了半天终于基本成型了。。。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]}