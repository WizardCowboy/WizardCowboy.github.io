{"meta":{"title":"Wizard Cowboy's blog","subtitle":null,"description":null,"author":"Wizard Cowboy","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-11T12:07:35.000Z","updated":"2018-05-11T12:07:35.959Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-11T12:22:22.000Z","updated":"2018-05-11T12:22:22.957Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-11T12:02:14.000Z","updated":"2018-05-11T12:02:14.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"图论-最短路","slug":"图论-最短路","date":"2018-06-24T11:36:29.000Z","updated":"2018-07-18T12:25:52.990Z","comments":true,"path":"2018/06/24/图论-最短路/","link":"","permalink":"http://yoursite.com/2018/06/24/图论-最短路/","excerpt":"问题类型 有时我们需要在一张图上求一个点到另外一个点的最短距离，这时就要用到最短路算法了。","text":"问题类型 有时我们需要在一张图上求一个点到另外一个点的最短距离，这时就要用到最短路算法了。 解决方案 假设我们已经有了一张n个点，m条边的图，我们要求s到t的最短路。 我们称s为源点，t为汇点，多源最短路即为有多个源点，单源最短路即为只有一个源点。 Floyd: 比较适用于多源最短路的情况。 我们用F[k][i][j]表示经过前k个点，从i到j的最短路。 所以F[k][i][j] = min(F[k - 1][i][j], F[k - 1][i][k] + F[k - 1][k][j]) 然后我们发现第一维可以被滚动掉，但我们仍要先枚举k，在枚举i，j。 时间复杂度为O(n ^ 3)。 Dijkstra: 适用于单源最短路的问题。 如果我们有一条u -&gt; v的长度为w的边，且Dis[u] + w &lt; Dis[v] 那么我们从s -&gt; u -&gt; v的路径肯定比s -&gt; v的路径优，所以我们更新Dis[v]的值。 我们把这个操作称为松弛操作。Dijkstra就是基于松弛操作的一个最短路算法。 我们对每个点都要松弛。我们每次找个Dis最小且未松弛过出边的点u，然后对它的出边进行松弛。 以上找点u的过程可以用堆来实现。时间复杂度为O(mlogm)。 SPFA: 适用于单源最短路的问题。 SPFA是Bellman-Ford的队列优化算法，也是基于松弛操作的。 我们每次对队列的队首元素u松弛它的出边(u,v)，如果被松弛了且v不在队列里，就把v加入队列。 时间复杂度为O(k*m)，k的最大值会被卡到n，但通常情况下平均值为2。 我们还可以对SPFA算法进行优化：SLF和LLL。 SLF: Small Label First，即我们在把v加入队列的时候，如果Dis[v] &lt; Dis[队首]则加到队首，否则加到队尾。 LLL: Large Label Last，我们每次在取出队首元素的时候判断一下，如果Dis[队首] &gt; 队列内Dis值的平均值，就把队首放入队尾，继续取出下一个队首。 SPFA还可以用来判负环，只要一个点进入队列&gt;=n次，原图中就有负环。 代码演示Floyd12345678void Floyd()&#123; rep(i, 1, n) F[i][i] = 0; rep(k, 1, n) rep(i, 1, n) rep(j, 1, n) F[i][j] = min(F[i][j], F[i][k] + F[k][j]);&#125; Dijkstra + Heap123456789101112131415161718192021priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; Q;void Dijkstra(int s)&#123; rep(i, 1, n) Dis[i] = INF, vis[i] = 0; Q.push(make_pair(0, s)); Dis[s] = 0; while (!Q.empty()) &#123; int u = Q.top().second; Q.pop(); if (vis[u]) continue; vis[u] = 1; travel(i, u) &#123; int v = edge[i].vet; if (!vis[v] &amp;&amp; Dis[v] &gt; Dis[u] + edge[i].val) &#123; Dis[v] = Dis[u] + edge[i].val; Q.push(make_pair(Dis[v], v)); &#125; &#125; &#125;&#125; SPFA1234567891011121314151617181920212223242526272829void SPFA(int s)&#123; int sum = 0, now = 1; rep(i, 1, n) vis[i] = 0, Dis[i] = INF; vis[s] = 1, Dis[s] = 0; Q.push_back(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop_front(); if (Dis[u] * now &gt; sum) //LLL &#123; Q.push_back(u); continue; &#125; sum -= Dis[u], now--; vis[u] = 0; travel(i, u) &#123; int v = edge[i].vet; if (Dis[v] &gt; Dis[u] + edge[i].val) &#123; Dis[v] = Dis[u] + edge[i].val; if (vis[v]) continue; if (Q.empty() || Dis[v] &gt; Dis[Q.front()]) Q.push_back(v); //SLF else Q.push_front(v); sum += Dis[v], now++; vis[v] = 1; &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/categories/图论/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"[BZOJ-3751]解方程","slug":"BZOJ-3751-解方程","date":"2018-06-23T00:37:52.000Z","updated":"2018-07-12T13:33:41.714Z","comments":true,"path":"2018/06/23/BZOJ-3751-解方程/","link":"","permalink":"http://yoursite.com/2018/06/23/BZOJ-3751-解方程/","excerpt":"Description 已知多项式方程： a0+a1x+a2x^2+…+an*x^n=0 求这个方程在[1,m]内的整数解（n和m均为正整数）。 ai ≤ 10^10000","text":"Description 已知多项式方程： a0+a1x+a2x^2+…+an*x^n=0 求这个方程在[1,m]内的整数解（n和m均为正整数）。 ai ≤ 10^10000 Solution 这是一道[NOIP2014]的题。 显然无法直接做，所以我们要用到hash的思想。 我们选取几个素数，如果一个数x在模这些素数意义下都使方程成立，那我们就认为这是方程的一个解。 Notice 注意ai的范围。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// BZOJ-3751.cpp// 模拟//// Created by 沈擎舟 on 2018/6/23.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 100, M = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int X[6][N + 5], Prime[6] = &#123;0, 11261, 14843, 19997, 21893, 22877&#125;, F[6][M + 5], Ans[M + 5];int n, m, num = 5, ans = 0;char st[M + 5];int Calc(int x, int cnt)&#123; int now = X[cnt][0], mi = 1; rep(i, 1, n) &#123; mi = mi * x % Prime[cnt]; now = (now + X[cnt][i] * mi) % Prime[cnt]; &#125; return now == 0;&#125;int sqz()&#123; n = read(), m = read(); rep(i, 0, n) &#123; scanf(\"%s\", st); int len = strlen(st), flag; if (st[0] == '-') flag = 0; else flag = st[0] - '0'; rep(j, 1, num) &#123; X[j][i] = flag; Rep(k, 1, len) X[j][i] = (X[j][i] * 10 + st[k] - '0') % Prime[j]; if (!flag) X[j][i] = -X[j][i]; &#125; &#125; rep(i, 1, num) Rep(j, 0, Prime[i]) F[i][j] = Calc(j, i); rep(i, 1, m) &#123; int flag = 1; rep(j, 1, num) if (!F[j][i % Prime[j]]) &#123; flag = 0; break; &#125; if (flag) Ans[++ans] = i; &#125; printf(\"%d\\n\", ans); rep(i, 1, ans) printf(\"%d\\n\", Ans[i]); return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-2456]mode","slug":"BZOJ-2456-mode","date":"2018-06-22T07:42:15.000Z","updated":"2018-07-11T13:33:40.241Z","comments":true,"path":"2018/06/22/BZOJ-2456-mode/","link":"","permalink":"http://yoursite.com/2018/06/22/BZOJ-2456-mode/","excerpt":"Description 给你一个n个数的数列，其中某个数出现了超过n / 2次即众数，请你找出那个数。 注意：空间限制1MB。","text":"Description 给你一个n个数的数列，其中某个数出现了超过n / 2次即众数，请你找出那个数。 注意：空间限制1MB。 Solution 如果没有空间限制，我们排个序就可以了。 因为题目保证了众数的个数大于n / 2，所以我们把每个数和一个与它不同的数相抵消，最后剩下的就是答案。 Notice 注意空间限制。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// BZOJ-2456.cpp// 模拟//// Created by 沈擎舟 on 2018/6/22.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cstdio&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int sqz()&#123; int n = read(), ans = 0, cnt = 0, x; rep(i, 1, n) &#123; x = read(); if (x == ans) cnt++; else if (cnt) cnt--; else ans = x, cnt = 1; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-2463]谁能赢呢？","slug":"BZOJ-2463-谁能赢呢？","date":"2018-06-22T07:35:18.000Z","updated":"2018-07-12T14:43:01.569Z","comments":true,"path":"2018/06/22/BZOJ-2463-谁能赢呢？/","link":"","permalink":"http://yoursite.com/2018/06/22/BZOJ-2463-谁能赢呢？/","excerpt":"Description 有一个n*n的棋盘，左上角有一个棋子。有两个人轮流移动棋子。若一个玩家无法移动则输。 每次都可以把棋子移动到它的上，下，左，右位置。求是先手必胜还是后手必胜。","text":"Description 有一个n*n的棋盘，左上角有一个棋子。有两个人轮流移动棋子。若一个玩家无法移动则输。 每次都可以把棋子移动到它的上，下，左，右位置。求是先手必胜还是后手必胜。 Solution 如果n*n是奇数，则先手必胜，否则后手必胜。 Notice 没什么需要注意的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// BZOJ-2463.cpp// 数学/博弈论//// Created by 沈擎舟 on 2018/6/22.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n;int sqz()&#123; while (~scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; if (n &amp; 1) puts(\"Bob\"); else puts(\"Alice\"); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"博弈","slug":"博弈","permalink":"http://yoursite.com/tags/博弈/"}]},{"title":"[BZOJ-3289]Mato的文件管理","slug":"BZOJ-3289-Mato的文件管理","date":"2018-06-22T05:08:49.000Z","updated":"2018-07-11T07:37:31.251Z","comments":true,"path":"2018/06/22/BZOJ-3289-Mato的文件管理/","link":"","permalink":"http://yoursite.com/2018/06/22/BZOJ-3289-Mato的文件管理/","excerpt":"Description 给你n个数，每次询问对于区间[L,R]，如果每次只能交换相邻两个数，要交换多少次才能使区间内的数从小到大有序。","text":"Description 给你n个数，每次询问对于区间[L,R]，如果每次只能交换相邻两个数，要交换多少次才能使区间内的数从小到大有序。 Solution 区间[L,R]的交换次数即为[L,R]的逆序对个数。 所以我们考虑如何求区间逆序对。 我们使用莫队和数状数组。 每次加入一个数，答案就加上这个数产生的贡献。 每次删除一个数，答案就减去这个数产生的贡献。 Notice 注意要开long long。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//// BZOJ-3289.cpp// 高级数据结构/莫队//// Created by 沈擎舟 on 2018/6/22.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int Belong[N + 5], Y[N + 5];ll Ans[N + 5];int cnt = 0;ll ans;struct node1&#123; int val, id;&#125;X[N + 5];int cmp1(node1 X, node1 Y)&#123; return X.val &lt; Y.val;&#125;struct node2&#123; int l, r, id;&#125;Q[N + 5];int cmp2(node2 X, node2 Y)&#123; return Belong[X.l] == Belong[Y.l] ? X.r &lt; Y.r : Belong[X.l] &lt; Belong[Y.l];&#125;struct BinaryIndexedTree&#123; int T[N + 5]; inline int lowbit(int x) &#123; return ((x) &amp; (-x)); &#125; inline void Modify(int u, int v) &#123; while (u &lt;= cnt) &#123; T[u] += v; u += lowbit(u); &#125; &#125; inline int Query(int u) &#123; int ans = 0; while (u) &#123; ans += T[u]; u -= lowbit(u); &#125; return ans; &#125;&#125;BIT;int sqz()&#123; int n = read(), Size = sqrt(n); rep(i, 1, n) X[i].val = read(), X[i].id = i, Belong[i] = (i - 1) / Size + 1; sort(X + 1, X + n + 1, cmp1); rep(i, 1, n) &#123; if (X[i].val != X[i - 1].val) cnt++; Y[X[i].id] = cnt; &#125; int m = read(); rep(i, 1, m) Q[i].l = read(), Q[i].r = read(), Q[i].id = i; sort(Q + 1, Q + m + 1, cmp2); int L = 1, R = 0; rep(i, 1, m) &#123; while (L &lt; Q[i].l) BIT.Modify(Y[L], -1), ans -= BIT.Query(Y[L] - 1), L++; while (L &gt; Q[i].l) --L, BIT.Modify(Y[L], 1), ans += BIT.Query(Y[L] - 1); while (R &gt; Q[i].r) BIT.Modify(Y[R], -1), ans -= R - L - BIT.Query(Y[R]), R--; while (R &lt; Q[i].r) ++R, BIT.Modify(Y[R], 1), ans += R - L + 1 - BIT.Query(Y[R]); Ans[Q[i].id] = ans; &#125; rep(i, 1, m) printf(\"%lld\\n\", Ans[i]); return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"[BZOJ-2038]小Z的袜子","slug":"BZOJ-2038-小Z的袜子","date":"2018-06-21T14:01:08.000Z","updated":"2018-07-08T14:08:15.358Z","comments":true,"path":"2018/06/21/BZOJ-2038-小Z的袜子/","link":"","permalink":"http://yoursite.com/2018/06/21/BZOJ-2038-小Z的袜子/","excerpt":"Description 读入n个数，询问区间[L,R]之间取两个数相同的概率为多少。","text":"Description 读入n个数，询问区间[L,R]之间取两个数相同的概率为多少。 Solution 这是一道[国家集训队2009]的题。 使用莫队即可。 Notice 注意要开long long。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//// BZOJ-2038.cpp// 高级数据结构/莫队//// Created by 沈擎舟 on 2018/6/21.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;struct node&#123; int l, r, id;&#125;Q[N + 5];int Belong[N + 5], X[N + 5], T[N + 5];ll Ansx[N + 5], Ansy[N + 5];ll ans = 0;int cmp(node X, node Y)&#123; return Belong[X.l] == Belong[Y.l] ? X.r &lt; Y.r : Belong[X.l] &lt; Belong[Y.l];&#125;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a % b) : a;&#125;void Insert(int pos)&#123; ans += T[X[pos]]; T[X[pos]]++;&#125;void Delete(int pos)&#123; T[X[pos]]--; ans -= T[X[pos]];&#125;int sqz()&#123; int n = read(), m = read(), Size = sqrt(n); rep(i, 1, n) X[i] = read(), Belong[i] = (i - 1) / Size + 1; rep(i, 1, m) Q[i].l = read(), Q[i].r = read(), Q[i].id = i; sort(Q + 1, Q + m + 1, cmp); int L = 1, R = 0; rep(i, 1, m) &#123; while (L &lt; Q[i].l) Delete(L++); while (L &gt; Q[i].l) Insert(--L); while (R &gt; Q[i].r) Delete(R--); while (R &lt; Q[i].r) Insert(++R); Ansx[Q[i].id] = ans, Ansy[Q[i].id] = (ll)(Q[i].r - Q[i].l + 1) * (Q[i].r - Q[i].l) / 2; &#125; rep(i, 1, m) &#123; ll g = gcd(Ansx[i], Ansy[i]); printf(\"%lld/%lld\\n\", Ansx[i] / g, Ansy[i] / g); &#125; return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"高级数据结构-莫队","slug":"高级数据结构-莫队","date":"2018-06-21T13:46:43.000Z","updated":"2018-07-08T13:59:05.665Z","comments":true,"path":"2018/06/21/高级数据结构-莫队/","link":"","permalink":"http://yoursite.com/2018/06/21/高级数据结构-莫队/","excerpt":"问题类型 适用于询问是一段区间[L,R]，可以离线，并且时间复杂度一个根号跑的过的情况下。","text":"问题类型 适用于询问是一段区间[L,R]，可以离线，并且时间复杂度一个根号跑的过的情况下。 解决方案 我们把n个数分成sqrt(n)个块，每个块就会有sqrt(n)个数。 假设i被分到了Belong[i]这个块。 我们先把所有询问按Belong[L]从小到大排序（如果Belong[L]相等，就按R从小到大）。 然后我们就把前一个区间暴力扩展删除到现在的区间为止。 L指针每一个询问最多移动sqrt(n)次，总共 q sqrt(n)。 R指针每不同的Belong[L]最多移动n次，最多sqrt(n)个块，总共 n sqrt(n)。 所以总时间复杂度为(n + q) * sqrt(n)。 代码演示1234567891011121314151617181920212223int cmp(node X, node Y)&#123; return Belong[X.l] == Belong[Y.l] ? X.r &lt; Y.r : Belong[X.l] &lt; Belong[Y.l];&#125;void Insert()void Delete()int main()&#123; init(); sort(Q + 1, Q + m + 1, cmp); int L = 1, R = 0; rep(i, 1, m) &#123; while (L &lt; Q[i].l) Delete(L++); while (L &gt; Q[i].l) Insert(--L); while (R &gt; Q[i].r) Delete(R--); while (R &lt; Q[i].r) Insert(++R); Ans[Q[i].id] = Calc(); &#125;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"[BZOJ-1008]越狱","slug":"BZOJ-1008-越狱","date":"2018-06-20T13:36:10.000Z","updated":"2018-07-08T13:44:59.029Z","comments":true,"path":"2018/06/20/BZOJ-1008-越狱/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1008-越狱/","excerpt":"Description 给你n个空格，每个格子可以填1~m的数，问有多少种存在两个相邻数相等的方案。","text":"Description 给你n个空格，每个格子可以填1~m的数，问有多少种存在两个相邻数相等的方案。 Solution 这是一道[HNOI2008]的题。 我们发现求有两个相邻的数相等比较难求，于是我们使用容斥，用总方案数减去没有相邻数相等的方案数。 所以答案就是 m ^ n - m * (m - 1) ^ n. Notice 注意要开long long Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// BZOJ-1008.cpp// 数学/容斥//// Created by 沈擎舟 on 2018/6/20.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 100003;const int N = 2000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;ll pow(ll a, ll b, ll Mo)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % Mo; a = a * a % Mo; b &gt;&gt;= 1; &#125; return ans;&#125;int sqz()&#123; ll m = read(), n = read(); printf(\"%lld\\n\", (pow(m, n, Mo) - m * pow(m - 1, n - 1, Mo) % Mo + Mo) % Mo); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/数学/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://yoursite.com/tags/容斥/"}]},{"title":"[BZOJ-1002]轮状病毒","slug":"BZOJ-1002-轮状病毒","date":"2018-06-20T11:12:04.000Z","updated":"2018-07-05T11:00:01.365Z","comments":true,"path":"2018/06/20/BZOJ-1002-轮状病毒/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1002-轮状病毒/","excerpt":"Description 如上图n轮状基由n个不同的基原子和圆心处的核原子构成。 n轮状病毒的产生就是n轮状基中删去若干条边，使得各原子间有唯一的信息通道。 求有多少个不同的n轮状病毒。","text":"Description 如上图n轮状基由n个不同的基原子和圆心处的核原子构成。 n轮状病毒的产生就是n轮状基中删去若干条边，使得各原子间有唯一的信息通道。 求有多少个不同的n轮状病毒。 Solution 这是一道[FJOI2007]的题。 打表找规律，我们发现F[i] = 3 * F[i - 1] - F[i - 2] + 2; Notice 我们发现可能会超出long long，所以我们要用到高精度。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410//// BZOJ-1002.cpp// DP/递推DP//// Created by 沈擎舟 on 2018/6/20.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 2000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;struct BigInteger&#123; int len, negative; int val[1005]; /* 转换 */ BigInteger(int x = 0) &#123; I_TO_B(x); &#125; BigInteger(char *st) &#123; C_TO_B(st); &#125; void C_TO_B(char *st) &#123; negative = 0; len = strlen(st); memset(val, 0, sizeof(val)); rep(i, 0, len - 1) val[i] = st[len - i - 1] - '0'; if (st[0] == '-') val[--len] = 0, negative = 1; while(len &gt; 0 &amp;&amp; val[len - 1] == 0) len--; &#125; void I_TO_B(int x) &#123; negative = 0; if (x &lt; 0) x = -x, negative = 1; len = 0; memset(val, 0, sizeof(val)); while(x) &#123; val[len++] = x % 10; x /= 10; &#125; &#125; /* 输入输出 */ friend istream &amp;operator &gt;&gt;(istream &amp;in, BigInteger &amp;t) &#123; char st[1005]; in &gt;&gt; st; t.C_TO_B(st); return in; &#125; friend ostream &amp;operator &lt;&lt;(ostream &amp;out, BigInteger &amp;t) &#123; if (t.negative) putchar('-'); per(i, t.len - 1, 0) out &lt;&lt; t.val[i]; return out; &#125; void print() &#123; if (negative) putchar('-'); per(i, len - 1, 0) putchar(val[i] + '0'); putchar('\\n'); &#125; /* 其他 */ friend void swap(BigInteger &amp;x, BigInteger &amp;y) &#123; BigInteger t = x; x = y; y = t; &#125; friend BigInteger operator -(BigInteger x) &#123; BigInteger t = x; t.negative = 1 - t.negative; return t; &#125; friend BigInteger abs(BigInteger x) &#123; BigInteger t = x; t.negative = 0; return t; &#125; /* 等于 or 不等于 */ friend bool operator ==(BigInteger x, BigInteger y) &#123; if (x.negative != y.negative) return 0; if (x.len != y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] != y.val[i]) return 0; return 1; &#125; friend bool operator ==(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x == y; &#125; friend bool operator ==(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x == y; &#125; friend bool operator !=(BigInteger x, BigInteger y) &#123; return !(x == y); &#125; friend bool operator !=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return !(x == y); &#125; friend bool operator !=(const int t, const BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return !(x == y); &#125; /* 小于 or 大于 */ friend bool operator &lt;(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; !y.negative) return 1; if (!x.negative &amp;&amp; y.negative) return 0; if (x.negative &amp;&amp; y.negative) swap(x, y); if (x.len &lt; y.len) return 1; if (x.len &gt; y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] &lt; y.val[i]) return 1; else if (x.val[i] &gt; y.val[i]) return 0; return 0; &#125; friend bool operator &lt;(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y; &#125; friend bool operator &lt;(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y; &#125; friend bool operator &gt;(BigInteger x, BigInteger y) &#123; return y &lt; x; &#125; friend bool operator &gt;(BigInteger x, int y) &#123; return y &lt; x; &#125; friend bool operator &gt;(int x, BigInteger y) &#123; return y &lt; x; &#125; /* 小于等于 or 大于等于 */ friend bool operator &lt;=(BigInteger x, BigInteger y) &#123; return x &lt; y || x == y; &#125; friend bool operator &lt;=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &lt;=(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &gt;=(BigInteger x, BigInteger y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(BigInteger x, int y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(int x, BigInteger y) &#123; return y &lt;= x; &#125; /* 加法 */ friend BigInteger operator +(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return -(abs(x) + abs(y)); if (x.negative &amp;&amp; !y.negative) return y - abs(x); if (!x.negative &amp;&amp; y.negative) return x - abs(y); int len = x.len &gt; y.len ? x.len : y.len; BigInteger ans; rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] + y.val[i]; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; if (ans.val[len] != 0) len++; ans.len = len; return ans; &#125; friend BigInteger operator +(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x + y; &#125; friend void operator +=(BigInteger &amp;x, BigInteger y) &#123; x = x + y; &#125; friend void operator +=(BigInteger &amp;x, int t) &#123; x = x + t; &#125; friend void operator ++(BigInteger &amp;x) &#123; x += 1; &#125; /* 减法 */ friend BigInteger operator -(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return abs(y) - abs(x); if (x.negative &amp;&amp; !y.negative) return -(abs(x) + y); if (!x.negative &amp;&amp; y.negative) return x + abs(y); BigInteger ans; if (x &lt; y) &#123; swap(x, y); ans.negative = 1; &#125; int len = max(x.len, y.len); rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] - y.val[i]; if (ans.val[i] &lt; 0) &#123; ans.val[i] += 10; ans.val[i + 1]--; &#125; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator -(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x - y; &#125; friend BigInteger operator -(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x - y; &#125; friend void operator -=(BigInteger &amp;x, BigInteger y) &#123; x = x - y; &#125; friend void operator -=(BigInteger &amp;x, int y) &#123; x = x - y; &#125; friend void operator --(BigInteger &amp;x) &#123; x -= 1; &#125; /* 乘法 */ friend BigInteger operator *(BigInteger x, BigInteger y) &#123; BigInteger ans; ans.negative = (x.negative ^ y.negative); int len = x.len + y.len; rep(i, 0, x.len - 1) rep(j, 0, y.len - 1) ans.val[i + j] += x.val[i] * y.val[j]; rep(i, 0, len - 1) &#123; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator *(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x * y; &#125; friend BigInteger operator *(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x * y; &#125; friend void operator *=(BigInteger &amp;x, BigInteger y) &#123; x = x * y; &#125; friend void operator *=(BigInteger &amp;x, int t) &#123; x = x * t; &#125; /* 除法 */ friend BigInteger operator /(BigInteger x, BigInteger y) &#123; BigInteger R, ans; if (y.len == 1 &amp;&amp; y.val[0] == 0) return R; per(i, x.len - 1, 0) &#123; ans *= 10; R = R * 10 + x.val[i]; while(R &gt;= y) &#123; ++ans; R -= y; &#125; &#125; return ans; &#125; friend BigInteger operator /(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x / y; &#125; friend BigInteger operator %(BigInteger x, BigInteger y) &#123; return x - x / y; &#125; friend BigInteger operator %(BigInteger x, int t) &#123; return x - x / t; &#125; friend void operator /=(BigInteger &amp;x, BigInteger y) &#123; x = x / y; &#125; friend void operator /=(BigInteger &amp;x, int t) &#123; x = x / t; &#125; friend void operator %=(BigInteger &amp;x, BigInteger y) &#123; x = x % y; &#125; friend void operator %=(BigInteger &amp;x, int t) &#123; x = x % t; &#125;&#125;Now, Pre1, Pre2;int sqz()&#123; Pre1 = 1, Pre2 = 0; int n = read(); if (n == 1) puts(\"1\"); else &#123; rep(i, 2, n) &#123; Now = Pre1 * 3 - Pre2 + 2; Pre2 = Pre1, Pre1 = Now; &#125; Now.print(); &#125; return 0;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/categories/高精度/"}],"tags":[{"name":"递推DP","slug":"递推DP","permalink":"http://yoursite.com/tags/递推DP/"},{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/tags/高精度/"}]},{"title":"高精度模版","slug":"高精度模版","date":"2018-06-20T11:07:09.000Z","updated":"2018-07-04T11:14:01.383Z","comments":true,"path":"2018/06/20/高精度模版/","link":"","permalink":"http://yoursite.com/2018/06/20/高精度模版/","excerpt":"问题类型 有时我们需要用到大于2^64的数的各种加减乘除运算，而C++中unsigned long long最多只支持2^64以内的数，这时我们就需要用到高精度了。","text":"问题类型 有时我们需要用到大于2^64的数的各种加减乘除运算，而C++中unsigned long long最多只支持2^64以内的数，这时我们就需要用到高精度了。 解决方案 我们用一个数组来模拟一个数的各个数位，来进行各种运算。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350struct BigInteger&#123; int len, negative; int val[1005]; /* 转换 */ BigInteger(int x = 0) &#123; I_TO_B(x); &#125; BigInteger(char *st) &#123; C_TO_B(st); &#125; void C_TO_B(char *st) &#123; negative = 0; len = strlen(st); memset(val, 0, sizeof(val)); rep(i, 0, len - 1) val[i] = st[len - i - 1] - '0'; if (st[0] == '-') val[--len] = 0, negative = 1; while(len &gt; 0 &amp;&amp; val[len - 1] == 0) len--; &#125; void I_TO_B(int x) &#123; negative = 0; if (x &lt; 0) x = -x, negative = 1; len = 0; memset(val, 0, sizeof(val)); while(x) &#123; val[len++] = x % 10; x /= 10; &#125; &#125; /* 输入输出 */ friend istream &amp;operator &gt;&gt;(istream &amp;in, BigInteger &amp;t) &#123; char st[1005]; in &gt;&gt; st; t.C_TO_B(st); return in; &#125; friend ostream &amp;operator &lt;&lt;(ostream &amp;out, BigInteger &amp;t) &#123; if (t.negative) putchar('-'); per(i, t.len - 1, 0) out &lt;&lt; t.val[i]; return out; &#125; void print() &#123; if (negative) putchar('-'); per(i, len - 1, 0) putchar(val[i] + '0'); putchar('\\n'); &#125; /* 其他 */ friend void swap(BigInteger &amp;x, BigInteger &amp;y) &#123; BigInteger t = x; x = y; y = t; &#125; friend BigInteger operator -(BigInteger x) &#123; BigInteger t = x; t.negative = 1 - t.negative; return t; &#125; friend BigInteger abs(BigInteger x) &#123; BigInteger t = x; t.negative = 0; return t; &#125; /* 等于 or 不等于 */ friend bool operator ==(BigInteger x, BigInteger y) &#123; if (x.negative != y.negative) return 0; if (x.len != y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] != y.val[i]) return 0; return 1; &#125; friend bool operator ==(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x == y; &#125; friend bool operator ==(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x == y; &#125; friend bool operator !=(BigInteger x, BigInteger y) &#123; return !(x == y); &#125; friend bool operator !=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return !(x == y); &#125; friend bool operator !=(const int t, const BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return !(x == y); &#125; /* 小于 or 大于 */ friend bool operator &lt;(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; !y.negative) return 1; if (!x.negative &amp;&amp; y.negative) return 0; if (x.negative &amp;&amp; y.negative) swap(x, y); if (x.len &lt; y.len) return 1; if (x.len &gt; y.len) return 0; per(i, x.len - 1, 0) if (x.val[i] &lt; y.val[i]) return 1; else if (x.val[i] &gt; y.val[i]) return 0; return 0; &#125; friend bool operator &lt;(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y; &#125; friend bool operator &lt;(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y; &#125; friend bool operator &gt;(BigInteger x, BigInteger y) &#123; return y &lt; x; &#125; friend bool operator &gt;(BigInteger x, int y) &#123; return y &lt; x; &#125; friend bool operator &gt;(int x, BigInteger y) &#123; return y &lt; x; &#125; /* 小于等于 or 大于等于 */ friend bool operator &lt;=(BigInteger x, BigInteger y) &#123; return x &lt; y || x == y; &#125; friend bool operator &lt;=(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &lt;=(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x &lt; y || x == y; &#125; friend bool operator &gt;=(BigInteger x, BigInteger y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(BigInteger x, int y) &#123; return y &lt;= x; &#125; friend bool operator &gt;=(int x, BigInteger y) &#123; return y &lt;= x; &#125; /* 加法 */ friend BigInteger operator +(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return -(abs(x) + abs(y)); if (x.negative &amp;&amp; !y.negative) return y - abs(x); if (!x.negative &amp;&amp; y.negative) return x - abs(y); int len = x.len &gt; y.len ? x.len : y.len; BigInteger ans; rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] + y.val[i]; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; if (ans.val[len] != 0) len++; ans.len = len; return ans; &#125; friend BigInteger operator +(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x + y; &#125; friend void operator +=(BigInteger &amp;x, BigInteger y) &#123; x = x + y; &#125; friend void operator +=(BigInteger &amp;x, int t) &#123; x = x + t; &#125; friend void operator ++(BigInteger &amp;x) &#123; x += 1; &#125; /* 减法 */ friend BigInteger operator -(BigInteger x, BigInteger y) &#123; if (x.negative &amp;&amp; y.negative) return abs(y) - abs(x); if (x.negative &amp;&amp; !y.negative) return -(abs(x) + y); if (!x.negative &amp;&amp; y.negative) return x + abs(y); BigInteger ans; if (x &lt; y) &#123; swap(x, y); ans.negative = 1; &#125; int len = max(x.len, y.len); rep(i, 0, len - 1) &#123; ans.val[i] += x.val[i] - y.val[i]; if (ans.val[i] &lt; 0) &#123; ans.val[i] += 10; ans.val[i + 1]--; &#125; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator -(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x - y; &#125; friend BigInteger operator -(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x - y; &#125; friend void operator -=(BigInteger &amp;x, BigInteger y) &#123; x = x - y; &#125; friend void operator -=(BigInteger &amp;x, int y) &#123; x = x - y; &#125; friend void operator --(BigInteger &amp;x) &#123; x -= 1; &#125; /* 乘法 */ friend BigInteger operator *(BigInteger x, BigInteger y) &#123; BigInteger ans; ans.negative = (x.negative ^ y.negative); int len = x.len + y.len; rep(i, 0, x.len - 1) rep(j, 0, y.len - 1) ans.val[i + j] += x.val[i] * y.val[j]; rep(i, 0, len - 1) &#123; ans.val[i + 1] += ans.val[i] / 10; ans.val[i] %= 10; &#125; while(len &gt; 1 &amp;&amp; ans.val[len - 1] == 0) len--; ans.len = len; return ans; &#125; friend BigInteger operator *(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x * y; &#125; friend BigInteger operator *(int t, BigInteger y) &#123; BigInteger x; x.I_TO_B(t); return x * y; &#125; friend void operator *=(BigInteger &amp;x, BigInteger y) &#123; x = x * y; &#125; friend void operator *=(BigInteger &amp;x, int t) &#123; x = x * t; &#125; /* 除法 */ friend BigInteger operator /(BigInteger x, BigInteger y) &#123; BigInteger R, ans; if (y.len == 1 &amp;&amp; y.val[0] == 0) return R; per(i, x.len - 1, 0) &#123; ans *= 10; R = R * 10 + x.val[i]; while(R &gt;= y) &#123; ++ans; R -= y; &#125; &#125; return ans; &#125; friend BigInteger operator /(BigInteger x, int t) &#123; BigInteger y; y.I_TO_B(t); return x / y; &#125; friend BigInteger operator %(BigInteger x, BigInteger y) &#123; return x - x / y; &#125; friend BigInteger operator %(BigInteger x, int t) &#123; return x - x / t; &#125; friend void operator /=(BigInteger &amp;x, BigInteger y) &#123; x = x / y; &#125; friend void operator /=(BigInteger &amp;x, int t) &#123; x = x / t; &#125; friend void operator %=(BigInteger &amp;x, BigInteger y) &#123; x = x % y; &#125; friend void operator %=(BigInteger &amp;x, int t) &#123; x = x % t; &#125;&#125;;","categories":[{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/categories/高精度/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/tags/高精度/"}]},{"title":"[BZOJ-1968]约束研究","slug":"BZOJ-1968-约束研究","date":"2018-06-20T11:04:34.000Z","updated":"2018-07-08T13:38:30.612Z","comments":true,"path":"2018/06/20/BZOJ-1968-约束研究/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1968-约束研究/","excerpt":"Description 求出1～n的约数个数和。","text":"Description 求出1～n的约数个数和。 Solution 这是一道[AHOI2005]的题。 我们考虑每个约数出现了多少次，枚举约数即可。 Notice 没什么要注意的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// BZOJ-1968.cpp// 模拟//// Created by 沈擎舟 on 2018/6/20.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 2000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int sqz()&#123; int n = read(), ans = 0; rep(i, 1, n) ans += n / i; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-1192]鬼谷子的钱袋","slug":"BZOJ-1192-鬼谷子的钱袋","date":"2018-06-20T10:29:18.000Z","updated":"2018-07-04T11:05:06.292Z","comments":true,"path":"2018/06/20/BZOJ-1192-鬼谷子的钱袋/","link":"","permalink":"http://yoursite.com/2018/06/20/BZOJ-1192-鬼谷子的钱袋/","excerpt":"Description 读入一个数n，你要求你至少把n拆分成几个数是的随意组合后能表示1～n的任意一个数。","text":"Description 读入一个数n，你要求你至少把n拆分成几个数是的随意组合后能表示1～n的任意一个数。 Solution 这是一道[HNOI2006]的题。 找到第一个大于n的2^k数，输出k。 Notice 注意是大于n的2^k数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// BZOJ-1192.cpp// 模拟//// Created by 沈擎舟 on 2018/6/20.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 1000000000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int sqz()&#123; int n = read(); int now = 1, cnt = 0; while (n &gt; now) n -= now, cnt++, now *= 2; printf(\"%d\\n\", cnt + 1);&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"[BZOJ-1864]三色二叉树","slug":"BZOJ-1864-三色二叉树","date":"2018-05-30T11:11:40.000Z","updated":"2018-05-30T11:45:07.780Z","comments":true,"path":"2018/05/30/BZOJ-1864-三色二叉树/","link":"","permalink":"http://yoursite.com/2018/05/30/BZOJ-1864-三色二叉树/","excerpt":"Description 一棵二叉树用一个由0,1,2的字符串表示。 如当前节点是叶子节点，则为0，若有一个儿子v则为1v。 若有两个儿子v1,v2则为2v1v2。 我们给每个节点染色（有3种颜色：红绿蓝），要求每个点的颜色与父亲和兄弟都不相同。 问最多和最少可以有多少个绿色节点。","text":"Description 一棵二叉树用一个由0,1,2的字符串表示。 如当前节点是叶子节点，则为0，若有一个儿子v则为1v。 若有两个儿子v1,v2则为2v1v2。 我们给每个节点染色（有3种颜色：红绿蓝），要求每个点的颜色与父亲和兄弟都不相同。 问最多和最少可以有多少个绿色节点。 Solution 这是一道[ZJOI2006]的题。 用树形DP即可。以求最大值为例： 我们用F[u][0]表示i不为绿色时子树中绿色节点数量的最大值。 我们用F[u][0]表示i为绿色时子树中绿色节点数量的最大值。 F[u][0] = Max(F[v1][1] + F[v2][0], F[v1][0] + F[v2][1]) F[u][1] = F[v1][0] + F[v2][0] 求最小值时同理。 Notice 建树时有些细节。 #Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//// BZOJ-1864.cpp// DP/树形DP//// Created by 沈擎舟 on 2018/5/30.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 51061;const int N = 100000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n = 0;int L[N + 5], R[N + 5], F[N + 5][2], G[N + 5][2];void dfs()&#123; int point = ++n; char ch = getchar(); if (ch == '0') return; if (ch == '1') &#123; L[point] = n + 1; dfs(); &#125; else &#123; L[point] = n + 1; dfs(); R[point] = n + 1; dfs(); &#125;&#125;void DP(int u)&#123; if (!u) return; DP(L[u]), DP(R[u]); F[u][1] = F[L[u]][0] + F[R[u]][0] + 1; F[u][0] = max(F[L[u]][1] + F[R[u]][0], F[L[u]][0] + F[R[u]][1]); G[u][1] = G[L[u]][0] + G[R[u]][0] + 1; G[u][0] = min(G[L[u]][1] + G[R[u]][0], G[L[u]][0] + G[R[u]][1]);&#125;int sqz()&#123; dfs(); DP(1); printf(\"%d %d\\n\", max(F[1][1], F[1][0]), min(G[1][1], G[1][0])); return 0;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"}]},{"title":"[BZOJ-2631]tree","slug":"BZOJ-2631-tree","date":"2018-05-29T01:42:27.000Z","updated":"2018-05-30T11:14:37.844Z","comments":true,"path":"2018/05/29/BZOJ-2631-tree/","link":"","permalink":"http://yoursite.com/2018/05/29/BZOJ-2631-tree/","excerpt":"Description 一棵n个点的树，每个点的初始权值为1。对于这棵树有q个操作，每个操作为以下四种操作之一： “+ u v c”：将u到v的路径上的点的权值都加上自然数c； “- u1 v1 u2 v2”：将树中原有的边(u1,v1)删除，加入一条新边(u2,v2)，保证操作完之后仍然是一棵树； “* u v c”：将u到v的路径上的点的权值都乘上自然数c； “/ u v”：询问u到v的路径上的点的权值和，求出答案对于51061的余数。","text":"Description 一棵n个点的树，每个点的初始权值为1。对于这棵树有q个操作，每个操作为以下四种操作之一： “+ u v c”：将u到v的路径上的点的权值都加上自然数c； “- u1 v1 u2 v2”：将树中原有的边(u1,v1)删除，加入一条新边(u2,v2)，保证操作完之后仍然是一棵树； “* u v c”：将u到v的路径上的点的权值都乘上自然数c； “/ u v”：询问u到v的路径上的点的权值和，求出答案对于51061的余数。 Solution LCT的模板题 Notice 注意Link和Cut的时候不用判是否联通，否则会TLE。 还有要用unsigned int，int会爆，longlong会被卡常。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//// BZOJ-2631.cpp// 高级数据结构/LCT//// Created by 沈擎舟 on 2018/5/29.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 51061;const int N = 100000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;char st[5];struct LinkCutTree&#123; int Fa[N + 5], Son[N + 5][2], rev[N + 5], Size[N + 5], Stack[N + 5], top; unsigned Sum[N + 5], Val[N + 5], Mul[N + 5], Add[N + 5]; inline void Modify(int u, int a, int m) &#123; if (!u) return; Sum[u] = (Sum[u] * m + Size[u] * a) % Mo; Val[u] = (Val[u] * m + a) % Mo; Mul[u] = (Mul[u] * m) % Mo; Add[u] = (Add[u] * m + a) % Mo; &#125; inline void up(int u) &#123; Size[u] = (Size[Son[u][0]] + Size[Son[u][1]] + 1) % Mo; Sum[u] = (Sum[Son[u][0]] + Sum[Son[u][1]] + Val[u]) % Mo; &#125; inline void down(int u) &#123; if (rev[u]) &#123; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; if (Add[u] != 0 || Mul[u] != 1) &#123; Modify(Son[u][0], Add[u], Mul[u]); Modify(Son[u][1], Add[u], Mul[u]); &#125; Add[u] = 0, Mul[u] = 1; &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y), up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[z][1] == y) ^ (Son[y][1] == x)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); Access(y); Splay(y); Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(), m = read(); rep(i, 1, n) LCT.Val[i] = LCT.Mul[i] = 1; Rep(i, 1, n) LCT.Link((int)read(), (int)read()); while (m--) &#123; scanf(\"%s\", st); if (st[0] == '+') &#123; int x = read(), y = read(), z = read(); LCT.Split(x, y), LCT.Modify(y, z, 1); &#125; if (st[0] == '-') &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(); LCT.Cut(x1, y1), LCT.Link(x2, y2); &#125; if (st[0] == '*') &#123; int x = read(), y = read(), z = read(); LCT.Split(x, y), LCT.Modify(y, 0, z); &#125; if (st[0] == '/') &#123; int x = read(), y = read(); LCT.Split(x, y); printf(\"%u\\n\", LCT.Sum[y]); &#125; &#125; return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-3669]魔法森林","slug":"BZOJ-3669-魔法森林","date":"2018-05-20T06:28:25.000Z","updated":"2018-05-30T11:14:26.776Z","comments":true,"path":"2018/05/20/BZOJ-3669-魔法森林/","link":"","permalink":"http://yoursite.com/2018/05/20/BZOJ-3669-魔法森林/","excerpt":"Description 给你一张n个点m条边的无向图，每条边有两个属性a和b。 你需要找到一条从1～n的路径，使得这些边的第一个属性最大值加上第二个属性最大值的值最小。","text":"Description 给你一张n个点m条边的无向图，每条边有两个属性a和b。 你需要找到一条从1～n的路径，使得这些边的第一个属性最大值加上第二个属性最大值的值最小。 Solution 这是一道[NOI2014]的题。 我们先把边按a的值从小到大排序，然后我们依次扫过每一条边。 这样我们当前边的a属性最大值是可以确定的，我们就要让b属性的最大值尽量小。 我们每扫描一条边，如果这条边的两端u,v已经相连了，那我们找到u到v的路径上b属性最大的边e。 如果e的b比当前的b要大，那么就割掉e与两端端点之间的连边，连接当前边与u,v的连边。 这样就保证了不会有环出现。 如果这条边两端u,v不相连，直接与u,v相连即可。 我们可以用LCT维护这个东西，把边权转化为点权。 Notice 我们用LCT维护b属性最大的边的序号可以更方便，而不是维护最大的b属性值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//// BZOJ-3669.cpp// 高级数据结构/LCT//// Created by 沈擎舟 on 2018/5/20.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 50000, M = 100000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;struct node&#123; int u, v, a, b; node() &#123;&#125; node(int _u, int _v, int _a, int _b) &#123;u = _u, v = _v, a = _a, b = _b;&#125;&#125;Edge[M + 5];inline int cmp(node X, node Y)&#123; return X.a &lt; Y.a;&#125;struct LinkCutTree&#123; int Val[N + M + 5], Fa[N + M + 5], Son[N + M + 5][2], rev[N + M + 5], Max[N + M + 5], Stack[N + M + 5], top; inline void up(int u) &#123; Max[u] = u; if (Son[u][0] &amp;&amp; Val[Max[Son[u][0]]] &gt; Val[Max[u]]) Max[u] = Max[Son[u][0]]; if (Son[u][1] &amp;&amp; Val[Max[Son[u][1]]] &gt; Val[Max[u]]) Max[u] = Max[Son[u][1]]; &#125; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y); up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[z][1] == y) ^ (Son[y][1] == x)) Rotate(x); Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(), m = read(), cnt = 0, ans = INF; rep(i, 1, m) &#123; int u = read(), v = read(), a = read(), b = read(); if (u == v) continue; Edge[++cnt] = node(u, v, a, b); &#125; sort(Edge + 1, Edge + cnt + 1, cmp); rep(i, 1, cnt) &#123; LCT.Val[n + i] = Edge[i].b; if (LCT.Find_Root(Edge[i].u) == LCT.Find_Root(Edge[i].v)) &#123; LCT.Split(Edge[i].u, Edge[i].v); int x = LCT.Max[Edge[i].v] - n; if (LCT.Val[x + n] &gt; Edge[i].b) &#123; LCT.Cut(x + n, Edge[x].u), LCT.Cut(x + n, Edge[x].v); LCT.Link(i + n, Edge[i].u), LCT.Link(i + n, Edge[i].v); &#125; &#125; else LCT.Link(i + n, Edge[i].u), LCT.Link(i + n, Edge[i].v); if (LCT.Find_Root(1) == LCT.Find_Root(n)) ans = min(ans, Edge[i].a + (LCT.Split(1, n), LCT.Val[LCT.Max[n]])); &#125; printf(\"%d\\n\", ans == INF ? -1 : ans); return 0;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-2049]洞穴勘测","slug":"BZOJ-2049-洞穴勘测","date":"2018-05-17T10:44:48.000Z","updated":"2018-05-17T10:54:41.723Z","comments":true,"path":"2018/05/17/BZOJ-2049-洞穴勘测/","link":"","permalink":"http://yoursite.com/2018/05/17/BZOJ-2049-洞穴勘测/","excerpt":"Description 有3种操作: 连接两个点，隔断两个点，问两个点是否联通。","text":"Description 有3种操作: 连接两个点，隔断两个点，问两个点是否联通。 Solution 这是一道[SDOI2008]的题。 LCT的裸题。 Notice 询问操作只要判断两个点的Find_Root即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//// BZOJ-2049.cpp// 高级数据结构/LCT//// Created by 沈擎舟 on 2018/5/17.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 10000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;char st[15];struct LinkCutTree&#123; int Fa[N + 5], Son[N + 5][2], rev[N + 5], Stack[N + 5], top; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[z][1] == y) ^ (Son[y][1] == x)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last; &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(), q = read(); while (q--) &#123; scanf(\"%s\", st); int x = read(), y = read(); if (st[0] == 'Q') &#123; if (LCT.Find_Root(x) == LCT.Find_Root(y)) puts(\"Yes\"); else puts(\"No\"); &#125; if (st[0] == 'C') LCT.Link(x, y); if (st[0] == 'D') LCT.Cut(x, y); &#125;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-2002]弹飞绵羊","slug":"BZOJ-2002-弹飞绵羊","date":"2018-05-17T07:34:16.000Z","updated":"2018-05-17T10:42:37.536Z","comments":true,"path":"2018/05/17/BZOJ-2002-弹飞绵羊/","link":"","permalink":"http://yoursite.com/2018/05/17/BZOJ-2002-弹飞绵羊/","excerpt":"Description 有n个装置，在第i个装置上会被弹到第i+X[i]个装置上，弹到大于n的装置即视为弹飞。 询问操作询问在一个装置弹几次会被弹飞，修改操作会修改X值。","text":"Description 有n个装置，在第i个装置上会被弹到第i+X[i]个装置上，弹到大于n的装置即视为弹飞。 询问操作询问在一个装置弹几次会被弹飞，修改操作会修改X值。 Solution 这是一道[HNOI2010]的题。 每次i和i+X[i]连边，从一个点走多少步走到n+1节点即为答案。 每次修改时先删边再加边即可。 Notice 注意原题中编号是0～n-1的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//// BZOJ-2002.cpp// 高级数据结构/LCT//// Created by 沈擎舟 on 2018/5/17.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 300000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int X[N + 5];struct LinkCutTree&#123; int Fa[N + 5], rev[N + 5], Son[N + 5][2], Size[N + 5], Stack[N + 5], top; inline void up(int u) &#123; Size[u] = Size[Son[u][0]] + Size[Son[u][1]] + 1; &#125; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; inline void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y); up(x); &#125; inline void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[y][1] == x) ^ (Son[z][1] == y)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u); Splay(u); rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;int sqz()&#123; int n = read(); rep(i, 1, n) X[i] = read(); rep(i, 1, n) LCT.Link(i, i + X[i] &lt;= n ? i + X[i] : n + 1); int q = read(); while (q--) &#123; int op = read(); if (op == 1) &#123; int x = read() + 1; LCT.Split(x, n + 1); printf(\"%d\\n\", LCT.Size[n + 1] - 1); &#125; else &#123; int x = read() + 1, y = read(); LCT.Cut(x, x + X[x] &lt;= n ? x + X[x] : n + 1); LCT.Link(x, x + y &lt;= n ? x + y : n + 1); X[x] = y; &#125; &#125;&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"高级数据结构-LCT","slug":"高级数据结构-LCT","date":"2018-05-16T04:30:42.000Z","updated":"2018-05-17T10:36:21.256Z","comments":true,"path":"2018/05/16/高级数据结构-LCT/","link":"","permalink":"http://yoursite.com/2018/05/16/高级数据结构-LCT/","excerpt":"问题类型 有时我们需要用一种数据结构去维护树形结构，并且支持删边加边操作。 这时我们就需要用到LCT了。","text":"问题类型 有时我们需要用一种数据结构去维护树形结构，并且支持删边加边操作。 这时我们就需要用到LCT了。 解决方案 LCT全称是Link_Cut_Tree，也叫做动态树。 LCT其实和轻重链剖分有些相似，我们给原树中的每个节点设置一个重儿子，到偏好儿子的边称为偏好边，一段连续的偏好边称为偏好链。 我们用每个splay去维护每个偏好链，在splay中以节点的深度做为关键字。 然后splay的根向splay深度最浅点在原树中的父亲连一条虚边。 LCT的基本操作： Access(u): 把u到原树的根的路径上所有边都变成偏好边，并且把u的偏好儿子设为空。 Make_Root(u): 把u变成原树的根。 Find_Root(u): 找出u所在的树的根。 Link(u, v): 连接u,v这条边 Cut(u, v): 割除u, v这条边 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct LinkCutTree&#123; int rev[N + 5], val[N + 5], Son[N + 5][2], Fa[N + 5], Stack[N + 5], top; inline void up(int u) &#123; val[u] = val[Son[u][0]] ^ val[Son[u][1]] ^ X[u]; &#125; inline void down(int u) &#123; if (!rev[u]) return; rev[Son[u][0]] ^= 1, rev[Son[u][1]] ^= 1, rev[u] ^= 1; swap(Son[u][0], Son[u][1]); &#125; inline int isroot(int u) &#123; return (Son[Fa[u]][0] != u &amp;&amp; Son[Fa[u]][1] != u); &#125; void Rotate(int x) &#123; int y = Fa[x], z = Fa[y]; int l = Son[y][1] == x, r = l ^ 1; if (!isroot(y)) Son[z][Son[z][1] == y] = x; Son[y][l] = Son[x][r], Fa[Son[x][r]] = y; Son[x][r] = y, Fa[y] = x, Fa[x] = z; up(y), up(x); &#125; void Splay(int x) &#123; Stack[top = 1] = x; for (int y = x; !isroot(y); y = Fa[y]) Stack[++top] = Fa[y]; per(i, top, 1) down(Stack[i]); while (!isroot(x)) &#123; int y = Fa[x], z = Fa[y]; if (!isroot(y)) &#123; if ((Son[y][1] == x) ^ (Son[z][1] == y)) Rotate(x); else Rotate(y); &#125; Rotate(x); &#125; &#125; inline void Access(int u) &#123; for (int last = 0; u; last = u, u = Fa[u]) Splay(u), Son[u][1] = last, up(u); &#125; inline void Make_Root(int u) &#123; Access(u), Splay(u), rev[u] ^= 1; &#125; inline int Find_Root(int u) &#123; Access(u), Splay(u); while (Son[u][0]) u = Son[u][0]; return u; &#125; inline void Split(int x, int y) &#123; Make_Root(x), Access(y), Splay(y); &#125; inline void Link(int x, int y) &#123; Make_Root(x); if (Find_Root(y) == x) return; Fa[x] = y; &#125; inline void Cut(int x, int y) &#123; Make_Root(x); if (Find_Root(y) != x || Fa[x] != y || Son[x][1]) return; Fa[x] = Son[y][0] = 0; &#125;&#125;LCT;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"[BZOJ-3572]世界树","slug":"BZOJ-3572-世界树","date":"2018-05-15T00:14:43.000Z","updated":"2018-05-15T00:32:47.132Z","comments":true,"path":"2018/05/15/BZOJ-3572-世界树/","link":"","permalink":"http://yoursite.com/2018/05/15/BZOJ-3572-世界树/","excerpt":"Description 给你一棵n个点的树，m次询问。 每次询问给出一些关键点，树上所有的点被距离它最近的关键点管辖，求每个关键点管辖多少点。 n ≤ 300000, m ≤ 300000, Sigma(关键点个数) &lt;= 300000","text":"Description 给你一棵n个点的树，m次询问。 每次询问给出一些关键点，树上所有的点被距离它最近的关键点管辖，求每个关键点管辖多少点。 n ≤ 300000, m ≤ 300000, Sigma(关键点个数) &lt;= 300000 Solution 这是一道[HNOI2014]的题。 我们可以用上下DP求出每个点被哪些点管辖，时间复杂度是 O(nm)的。 我们考虑建出虚树，建完虚树后用上下DP处理出虚树上每个点被哪些关键点管辖。 然后我们考虑一个关键点可以管辖哪些点。 对于深度比它大的点，一定是它的子树去掉某些子树。对于深度比它小的点，一定是它的某个祖先的子树去掉它。 我们考虑枚举虚树上的每一条边：如果它两端点不被同一个关键点管辖，则倍增找出一个分界点，然后处理答案即可。 Notice 此题细节较多，处理很麻烦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//// BZOJ-3572.cpp// 高级数据结构/虚树//// Created by 沈擎舟 on 2018/5/15.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 300000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n, m, edgenum = 0, num, idx;int head[N + 5], Belong[N + 5], Size[N + 5], Rest[N + 5], Ans[N + 5], Dis[N + 5], Deep[N + 5], Fa[N + 5][20], X[N + 5], Y[N + 5], Z[N + 5], dfn[N + 5], stack[N + 5];struct node&#123; int vet, next;&#125;edge[2 * N + 5];void addedge(int u, int v)&#123; edge[edgenum].vet = v; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;int cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y];&#125;void dfs(int u, int fa)&#123; Size[u] = 1, Deep[u] = Deep[fa] + 1, dfn[u] = ++idx, Fa[u][0] = fa; rep(i, 1, 19) Fa[u][i] = Fa[Fa[u][i - 1]][i - 1]; travel(i, u) &#123; int v = edge[i].vet; if (v == fa) continue; dfs(v, u); Size[u] += Size[v]; &#125;&#125;int lca(int x, int y)&#123; if (Deep[x] &lt; Deep[y]) swap(x, y); per(i, 19, 0) if (Deep[Fa[x][i]] &gt;= Deep[y]) x = Fa[x][i]; if (x == y) return x; per(i, 19, 0) if (Fa[x][i] != Fa[y][i]) x = Fa[x][i], y = Fa[y][i]; return Fa[x][0];&#125;void Build()&#123; sort(X + 1, X + m + 1, cmp); int top = 0; stack[++top] = 1; rep(i, 1, m) &#123; if (X[i] == 1) continue; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; addedge(Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1], stack[top]); top--; &#125; if (!top || stack[top] != u) stack[++top] = u; stack[++top] = X[i]; &#125; while (--top) addedge(stack[top], stack[top + 1]);&#125;void up_dfs(int u)&#123; Z[++num] = u; Rest[u] = Size[u]; travel(i, u) &#123; int v = edge[i].vet; up_dfs(v); if (!Belong[v]) continue; int dis1 = Deep[Belong[v]] - Deep[u], dis2 = Belong[u] ? Deep[Belong[u]] - Deep[u] : INF; if (dis1 &lt; dis2 || dis1 == dis2 &amp;&amp; Belong[v] &lt; Belong[u]) Belong[u] = Belong[v]; &#125; Dis[u] = Deep[Belong[u]] - Deep[u];&#125;void down_dfs(int u)&#123; travel(i, u) &#123; int v = edge[i].vet; int dis1 = Dis[u] + Deep[v] - Deep[u], dis2 = Dis[v]; if (dis1 &lt; dis2 || dis1 == dis2 &amp;&amp; Belong[u] &lt; Belong[v]) Belong[v] = Belong[u], Dis[v] = dis1; down_dfs(v); &#125;&#125;void Solve(int u, int v)&#123; int mid = v; if (Belong[u] == Belong[v]) &#123; Rest[u] -= Size[v]; return; &#125; per(i, 19, 0) &#123; int x = Fa[mid][i]; if (Deep[x] &lt;= Deep[u]) continue; int dis1 = Dis[u] + Deep[x] - Deep[u], dis2 = Dis[v] + Deep[v] - Deep[x]; if (dis1 &gt; dis2 || dis1 == dis2 &amp;&amp; Belong[u] &gt; Belong[v]) mid = x; &#125; Rest[u] -= Size[mid]; Ans[Belong[v]] += Size[mid] - Size[v];&#125;int sqz()&#123; n = read(); rep(i, 1, n) head[i] = -1; Rep(i, 1, n) &#123; int u = read(), v = read(); addedge(u, v), addedge(v, u); &#125; dfs(1, 0); edgenum = 0; rep(i, 1, n) head[i] = -1; int q = read(); while (q--) &#123; m = read(); num = idx = 0; rep(i, 1, m) X[i] = Y[i] = read(), Belong[X[i]] = X[i]; Build(); up_dfs(1); down_dfs(1); rep(i, 1, num) travel(j, Z[i]) Solve(Z[i], edge[j].vet); rep(i, 1, num) Ans[Belong[Z[i]]] += Rest[Z[i]]; rep(i, 1, m) printf(\"%d%c\", Ans[Y[i]], i == m ? '\\n' : ' '); rep(i, 1, num) head[Z[i]] = -1, Belong[Z[i]] = Ans[Z[i]] = Rest[Z[i]] = 0; &#125;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"},{"name":"上下DP","slug":"上下DP","permalink":"http://yoursite.com/tags/上下DP/"}]},{"title":"[BZOJ-2286]消耗战","slug":"BZOJ-2286-消耗战","date":"2018-05-12T01:08:49.000Z","updated":"2018-07-04T10:29:49.193Z","comments":true,"path":"2018/05/12/BZOJ-2286-消耗战/","link":"","permalink":"http://yoursite.com/2018/05/12/BZOJ-2286-消耗战/","excerpt":"Description 给你一棵n个点的树，每条边上有边权。 有m次询问，每次询问都给出一些关键点。你要割掉一些边，使得从1出发无法到达这些关键点。 求割掉边的边权总和最小值。 n ≤ 250000, m ≥ 1, Sigma(关键点个数) ≤ 500000","text":"Description 给你一棵n个点的树，每条边上有边权。 有m次询问，每次询问都给出一些关键点。你要割掉一些边，使得从1出发无法到达这些关键点。 求割掉边的边权总和最小值。 n ≤ 250000, m ≥ 1, Sigma(关键点个数) ≤ 500000 Solution 这是一道[SDOI2011]的题。 首先我们考虑树形DP，F[u]表示从u出发到不了u的子树中所有关键点的最小代价。 那么如果u的儿子v是关键点，那么F[u] += Dis(u, v)——(u, v)这条边一定得割 否则F[u] += min(F[v], Dis(u, v)) 这样我们得到了一个O(n)的DP，但询问m次后时间复杂度就很大了。 所以我们需要用虚树处理，这样总时间复杂度就是O(关键点个数)了。 Notice 因为这道题是树形DP，只要从下向上转移即可，所以不用把虚树边练出来，只要记录每个关键点及LCA在虚树中的父亲即可。 还要倍增预处理祖先和到祖先边权的最小值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//// BZOJ-2286.cpp// 高级数据结构/虚树//// Created by 沈擎舟 on 2018/5/11.// Copyright © 2018年 Derec Emerald. All rights reserved.//#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define sqz main#define ll long long#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define Rep(i, a, b) for (int i = (a); i &lt; (b); i++)#define travel(i, u) for (int i = head[u]; ~i; i = edge[i].next)const ll INF = 1e9, Mo = 998244353;const int N = 250000;const double eps = 1e-6;namespace slow_IO&#123; ll read() &#123; ll x = 0; int zf = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') zf = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf; &#125; void write(ll y) &#123; if (y &lt; 0) putchar('-'), y = -y; if (y &gt; 9) write(y / 10); putchar(y % 10 + '0'); &#125;&#125;using namespace slow_IO;int n, num, tmp, edgenum = 0, Time = 0, top;int head[N + 5], X[N + 5], Y[N + 5], dfn[N + 5], Deep[N + 5], fa[N + 5], Fa[N + 5][20], Dis[N + 5][20], stack[N + 5], flag[N + 5];ll Ans[N + 5];struct node&#123; int vet, val, next;&#125;edge[2 * N + 5];void addedge(int u, int v, int w)&#123; edge[edgenum].vet = v; edge[edgenum].val = w; edge[edgenum].next = head[u]; head[u] = edgenum++;&#125;void dfs(int u, int fa)&#123; dfn[u] = ++Time; Deep[u] = Deep[fa] + 1; travel(i, u) &#123; int v = edge[i].vet; if (v == fa) continue; Fa[v][0] = u, Dis[v][0] = edge[i].val; dfs(v, u); &#125;&#125;void Prepare()&#123; rep(i, 1, 18) rep(j, 1, n) &#123; Fa[j][i] = Fa[Fa[j][i - 1]][i - 1]; Dis[j][i] = min(Dis[j][i - 1], Dis[Fa[j][i - 1]][i - 1]); &#125;&#125;int lca(int u, int v)&#123; if (Deep[u] &lt; Deep[v]) swap(u, v); per(i, 18, 0) if (Deep[Fa[u][i]] &gt;= Deep[v]) u = Fa[u][i]; if (u == v) return u; per(i, 18, 0) if (Fa[u][i] != Fa[v][i]) u = Fa[u][i], v = Fa[v][i]; return Fa[u][0];&#125;int dis(int u, int v)&#123; int ans = INF; if (Deep[u] &lt; Deep[v]) swap(u, v); per(i, 18, 0) if (Deep[Fa[u][i]] &gt;= Deep[v]) ans = min(ans, Dis[u][i]), u = Fa[u][i]; return ans;&#125;int cmp(int x, int y)&#123; return dfn[x] &lt; dfn[y];&#125;void Build()&#123; sort(X + 1, X + num + 1, cmp); stack[top = 1] = X[1]; rep(i, 2, num) &#123; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; fa[stack[top]] = Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1]; top--; &#125; if (!top || u != stack[top]) &#123; X[++tmp] = u; stack[++top] = u; &#125; stack[++top] = X[i]; &#125; while (--top) fa[stack[top + 1]] = stack[top];&#125;ll solve()&#123; sort(X + 1, X + tmp + 1, cmp); rep(i, 1, tmp) Ans[X[i]] = 0; per(i, tmp, 2) &#123; if (flag[X[i]]) Ans[fa[X[i]]] += (ll)dis(X[i], fa[X[i]]); else Ans[fa[X[i]]] += min((ll)dis(X[i], fa[X[i]]), Ans[X[i]]); &#125; return Ans[1];&#125;int sqz()&#123; n = read(); rep(i, 1, n) head[i] = -1; Rep(i, 1, n) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w), addedge(v, u, w); &#125; dfs(1, 0); Prepare(); int m = read(); while (m--) &#123; tmp = num = read() + 1, X[1] = 1; rep(i, 2, num) X[i] = Y[i] = read(), flag[X[i]] = 1; Build(); printf(\"%lld\\n\", solve()); rep(i, 2, num) flag[Y[i]] = 0; &#125;&#125;","categories":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/categories/DP/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"},{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"}]},{"title":"高级数据结构-虚树","slug":"高级数据结构-虚树","date":"2018-05-11T16:00:00.000Z","updated":"2018-05-16T05:23:08.915Z","comments":true,"path":"2018/05/12/高级数据结构-虚树/","link":"","permalink":"http://yoursite.com/2018/05/12/高级数据结构-虚树/","excerpt":"问题类型 有些问题一次询问需要O(n)的复杂度，但多次询问时间复杂度会很大。 但如果我们只需要用到题目中给出的一些关键点和它们的LCA，并且给出的关键点个数总和并不多，我们可以求出它们的LCA，建成虚树，一次询问就变成了O(关键点个数)","text":"问题类型 有些问题一次询问需要O(n)的复杂度，但多次询问时间复杂度会很大。 但如果我们只需要用到题目中给出的一些关键点和它们的LCA，并且给出的关键点个数总和并不多，我们可以求出它们的LCA，建成虚树，一次询问就变成了O(关键点个数) 解决方案 从上文得知，我们需要找出关键点的LCA并且建成虚树。 这时我们就需要用到栈。（在后文我们简称关键点的LCA为重要点） 我们用栈维护从根到当前关键点的路径上的重要点。 我们先把关键点按DFS序从小到大排序。 然后每次新枚举一个关键点u，求出它与栈顶v（上一个关键点）的LCA:w。 如果u是v的子孙，那么w=v，直接把u加入栈即可。 如果u不是v的子孙，那么w的深度一定比v要浅，所以我们就一直弹栈顶，知道栈顶的深度≤w的深度。 这时如果栈顶不是w，再把w加入栈。最后再把当前关键点加入栈。 我们在每次弹栈的时候，就把栈顶和相邻元素连边。（注意最后还要把栈弹空） 代码演示1234567891011121314151617void Build()&#123; sort(X + 1, X + num + 1, cmp); stack[top = 1] = X[1]; rep(i, 2, num) &#123; int u = lca(X[i], stack[top]); while (top &amp;&amp; Deep[stack[top]] &gt; Deep[u]) &#123; addedge(stack[top], Deep[stack[top - 1]] &lt; Deep[u] ? u : stack[top - 1]); top--; &#125; if (!top || u != stack[top]) stack[++top] = u; stack[++top] = X[i]; &#125; while (--top) addedge(stack[top + 1]], stack[top]);&#125;","categories":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://yoursite.com/categories/高级数据结构/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://yoursite.com/tags/虚树/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-05-11T11:21:10.000Z","updated":"2018-07-04T11:15:07.614Z","comments":true,"path":"2018/05/11/Hello-World/","link":"","permalink":"http://yoursite.com/2018/05/11/Hello-World/","excerpt":"Wizard Cowboy终于有自己的博客啦 搞了半天终于基本成型了。。。","text":"Wizard Cowboy终于有自己的博客啦 搞了半天终于基本成型了。。。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]}